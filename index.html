<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="welcome to my blog!!">
<meta property="og:type" content="website">
<meta property="og:title" content="wenguolong">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wenguolong">
<meta property="og:description" content="welcome to my blog!!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wenguolong">
<meta name="twitter:description" content="welcome to my blog!!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>wenguolong</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wenguolong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">solve the problems encountered in the learning process and solutions!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/302和302的详细解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/302和302的详细解析/" itemprop="url">301和302</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-27T22:11:32+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直对http状态码301和302的理解比较模糊，在遇到实际的问题和翻阅各种资料了解后，算是有了一定的理解。这里记录下，希望能有新的认识。大家也共勉。</p>
<p>官方的比较简洁的说明：</p>
<pre><code>  301 redirect: 301 代表永久性转移(Permanently Moved)

  302 redirect: 302 代表暂时性转移(Temporarily Moved )

  ps:这里也顺带记住了两个比较相近的英语单词（permanently、temporarily），嘻哈！



  详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个
  新的URL地址这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间
  变成了另一个地址B）——这是它们的共同点。
  他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容
  的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向
  只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。

这里开启傻瓜自问自答模式（自己可能想到的疑问）：
</code></pre><p>1、什么是重定向啊？</p>
<pre><code>就是地址A跳转到地址B啦。百度百科的解释：重定向(Redirect)
就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、
路由选择的变化也是对数据报文经由路径的一种重定向）。
</code></pre><p>2、可是，为什么要进行重定向啊？什么时候需要重定向呢？</p>
<pre><code>想跳就跳，就跳的漂亮。还是借鉴百度百科：
</code></pre><p>1）网站调整（如改变网页目录结构）；<br>2）网页被移到一个新地址；<br>3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。<br>        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>
<p>3、那么，什么时候进行301或者302跳转呢？<br>        当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。<br>    清晰明确而言：<br>使用301跳转的场景：<br>1）域名到期不想续费（或者发现了更适合网站的域名），想换个域名。<br>2）在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。<br>3）空间服务器不稳定，换空间的时候。</p>
<p>使用302跳转的场景：<br>        –尽量使用301跳转！</p>
<p>4、为什么尽量要使用301跳转？——网址劫持！<br>        这里摘录百度百科上的解释：<br>        从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302 重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL 劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302 重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。302 重定向所造成的网址URL 劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的谷歌大爸爸数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。<br>        我的理解是，从网站A（网站比较烂）上做了一个302跳转到网站B（搜索排名很靠前），这时候有时搜索引擎会使用网站B的内容，但却收录了网站A的地址，这样在不知不觉间，网站B在为网站A作贡献，网站A的排名就靠前了。<br>      301跳转对查找引擎是一种对照驯良的跳转编制，也是查找引擎能够遭遇的跳转编制，它告诉查找引擎，这个地址弃用了，永远转向一个新地址，可以转移新域名的权重。而302重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉，罪名是“利用重复的内容来干扰Google搜索结果的网站排名”。</p>
<pre><code>自问自答模式先告一段落，这里分享下我在NodeJs中实现跳转的场景：
之前做过一个重构的项目，由于各种原因，我们的网站的登录以及注册部分需要剥离为另一个网站，域名
和之前的不同，所以，
我们需要保证旧的地址也能重定向到地址中去，我们就在旧的系统的node层中作了一个重定向，代码类似这样：
</code></pre><p>这里没有设置状态码，发现默认是302跳转，然后我们设置了301状态码，类似这样：</p>
<p>用fiddle抓包(上面的302调整我就不上图了)，看到效果:</p>
<p>以上是使用Express，用nodejs原生的代码实现类似这样：</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/21/ES6中的箭头函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/21/ES6中的箭头函数/" itemprop="url">ES6中的箭头函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-21T11:43:53+08:00">
                2017-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index">
                    <span itemprop="name">ES6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <article id="wikiArticle">



<p>一个<strong>箭头函数表达式</strong>的语法比一个<a href="/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更短，并且不绑定自己的 <a href="/zh-CN/docs/Web/JavaScript/Reference/Operators/this">this</a>，<a href="/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a>，<a href="/zh-CN/docs/Web/JavaScript/Reference/Operators/super">super</a>或&nbsp;<a href="/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target">new.target</a>。</p>

<p>这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。</p>

<h2 id="Syntax" name="Syntax" class="highlight-spanned"><span class="highlight-span">语法</span></h2>

<h3 id="基础语法">基础语法</h3>

<pre class="syntaxbox"><strong>(</strong><em>param1</em>, <em>param2</em>, …, <em>paramN</em><strong>) =&gt; {</strong> <em>statements</em> <strong>}
(</strong><em>param1</em>, <em>param2</em>, …, <em>paramN</em><strong>) =&gt;</strong> <em>expression
</em>// 等价于：<strong>(</strong><em>param1</em>, <em>param2</em>, …, <em>paramN</em><strong>) =&gt;</strong> { return expression; }
/* 当删除大括号时，它将是一个隐式的返回值，这意味着我们不需要指定我们返回*/

// 如果只有一个参数，圆括号是可选的:
<em>(singleParam)</em> <strong>=&gt; {</strong> <em>statements;</em> <strong>}</strong>
<em>singleParam</em> <strong>=&gt;</strong> { <em>statements; }</em>

// 如果箭头函数 无参数 , 必须使用 ()圆括号或者 _下划线:
<strong>() =&gt; {</strong> <em>statements;</em> <strong>} 
</strong>或<strong>
_ =&gt; { statements; }</strong>
</pre>

<h3 id="高级语法">高级语法</h3>

<pre class="syntaxbox">//返回一个对象时，函数体外要加圆括号
<em>params</em> =&gt; ({<em>foo: bar</em>})

// 支持 <a href="/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">剩余参数</a>和<a href="/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters">默认参数</a>:
(<em>param1</em>, <em>param2</em>, <strong>...rest</strong>) =&gt; { <em>statements</em> }

// <strong>...rest </strong>参数, 必须是参数列表<strong>最后一个参数</strong>
<img src="https://mdn.mozillademos.org/files/15037/7dd52b92-3a8f-11e7-8040-f3a8f7d73e6d.png" alt="Rest_parameters(es6) Array function" style="height: 538px; width: 729px;">


(<em>param1</em> <strong>= defaultValue1</strong>, <em>param2</em>, …, paramN <strong>= defaultValueN</strong>) =&gt; { <em>statements</em> }

// 也支持参数列表中的<a href="/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a>
let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; // a=1; b=2; x=c; c=a+b=3;
f();  // 6
</pre>

<p>&nbsp;</p>

<h2 id="描述" class="highlight-spanned"><span class="highlight-span">描述</span></h2>

<p>另见&nbsp;<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/" class="external external-icon" target="_blank" rel="external">“ES6 In Depth: Arrow functions” on hacks.mozilla.org</a>.</p>

<p>箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对&nbsp;<code>this</code>的词法解析<code>。</code></p>

<h3 id="更短的函数">更短的函数</h3>

<p>更短的函数在函数式编程里很受欢迎。试比较：</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">"Hydrogen"</span><span class="token punctuation">,</span>
  <span class="token string">"Helium"</span><span class="token punctuation">,</span>
  <span class="token string">"Lithium"</span><span class="token punctuation">,</span>
  <span class="token string">"Beryl­lium"</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> a2 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>length <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> a3 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span> s <span class="token operator">=</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>length <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="不绑定_this"><code>不绑定 this</code></h3>

<p>在箭头函数出现之前，每个新定义的函数都有其自己的&nbsp;<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">this</a>&nbsp;</code>值（例如，构造函数的 this 指向了一个新的对象；<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="external">严格模式</a>下的函数的 <code>this</code> 值为 <code>undefined</code>；如果函数是作为对象的方法被调用的，则其 this 指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 构造函数 Person() 定义的 `this` 就是新实例对象自己</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">growUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 在非严格模式下，growUp() 函数定义了其内部的 `this`为全局对象, </span>
        <span class="token comment" spellcheck="true">// 不同于构造函数Person()的定义的 `this`</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 ECMAScript 3/5 中，这个问题通过把this的值赋给变量，然后将该变量放到闭包中来解决。</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">// 也有人选择使用 `that` 而非 `self`, 只要保证一致就好.</span>
    self<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">growUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 回调里面的 `self` 变量就指向了期望的那个对象了</span>
        self<span class="token punctuation">.</span>age<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>除此之外，还可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">bind 函数</a>，把期望的&nbsp;<code>this </code>值传递给&nbsp;<code>growUp()</code>&nbsp;函数。</p>

<p>箭头函数会捕获其所在上下文的 &nbsp;<code>this</code> 值，作为自己的 <code>this</code> 值，因此下面的代码将如期运行。</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 回调里面的 `this` 变量就指向了期望的那个对象了</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="与严格模式的关系">与严格模式的关系</h4>

<p>考虑到&nbsp;<code>this</code>&nbsp;是词法层面上的，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="external">严格模式</a>中与&nbsp;<code>this</code>&nbsp;相关的规则都将被忽略。</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token string">'use strict'</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> window<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或全局对象</span><span class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>严格模式的其他规则依然不变.</p>

<h4 id="使用_call_或_apply_调用">使用 call 或&nbsp;apply 调用</h4>

<p>由于&nbsp;<code>this</code><em>&nbsp;</em>已经在词法层面完成了绑定，通过&nbsp;<code>call()</code><em>&nbsp;或</em>&nbsp;<code>apply()</code>&nbsp;方法调用一个函数时，只是传入了参数而已，对&nbsp;<code>this</code>&nbsp;并没有什么影响：</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token keyword">var</span> adder <span class="token operator">=</span> <span class="token punctuation">{</span>
  base <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>

  add <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> f <span class="token operator">=</span> v <span class="token operator">=</span><span class="token operator">&gt;</span> v <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>base<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  addThruCall<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> f <span class="token operator">=</span> v <span class="token operator">=</span><span class="token operator">&gt;</span> v <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>base<span class="token punctuation">;</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>
      base <span class="token punctuation">:</span> <span class="token number">2</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>adder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 输出 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>adder<span class="token punctuation">.</span><span class="token function">addThruCall</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 仍然输出 2（而不是3 ——译者注）</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="不绑定参数（arguments）"><code>不绑定参数（arguments）</code></h3>

<p>箭头函数不会在其内部暴露出参数（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external"><code>arguments</code></a>&nbsp;)：&nbsp;<code>arguments.length</code>,&nbsp;<code>arguments[0]</code>,&nbsp;<code>arguments[1]</code> 等等，<b>都不会指向箭头函数的 arguments，而是指向了箭头函数所在作用域的一个名为 arguments 的值</b>（如果有的话，否则，就是 undefined。——译者注）。</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token keyword">var</span> arguments <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> arguments<span class="token punctuation">;</span>

<span class="token function">arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 42</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">;</span> 
  <span class="token comment" spellcheck="true">// foo函数的间接参数绑定</span>
  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>箭头函数没有自己的&nbsp;<code>arguments</code>&nbsp;，不过在大多数情形下，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="external">rest参数</a>可以给出一个解决方案：</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 2</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="像方法一样使用箭头函数">像方法一样使用箭头函数</h3>

<p>如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token string">'use strict'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  i<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>i<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  c<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>i<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// undefined</span>
obj<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 10, Object {...}</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>箭头函数没有定义this绑定。 另一个涉及<a title="Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。" href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a>:的示例：</p>

<pre class="brush: js line-numbers  language-js"><code class="  language-js"><span class="token string">'use strict'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> <span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span> 
   <span class="token comment" spellcheck="true">// represents global object 'Window', therefore 'this.a' returns 'undefined'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="使用_new_操作符">使用&nbsp;<code>new</code>&nbsp;操作符</h3>

<p>箭头函数不能用作构造器，和 new 一起用就会抛出错误。</p>

<pre><code>var Foo = () =&gt; {};
var foo = new Foo(); 
// TypeError: Foo is not a constructor</code></pre>

<h3 id="使用原型属性">使用原型属性</h3>

<p>箭头函数没有原型属性。</p>

<pre><code>var Foo = () =&gt; {};
console.log(Foo.prototype); 
// undefined</code></pre>

<h3 id="使用_yield_关键字">使用&nbsp;<code>yield</code>&nbsp;关键字</h3>

<p>&nbsp;<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" target="_blank" rel="external">yield</a></code>&nbsp;关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。</p>

<h2 id="函数主体" class="highlight-spanned"><span class="highlight-span">函数主体</span></h2>

<p>箭头函数既支持简写也支持常规编写。</p>

<p>简写时只需要一个表达式和一个返回值。常规编写时必须有一个明确的返回值。</p>

<pre><code>var func = x =&gt; x * x;                  
// 简写函数 省略return

var func = (x, y) =&gt; { return x + y; }; 
//常规编写 明确的返回值</code></pre>

<h2 id="返回文字表达式" class="highlight-spanned"><span class="highlight-span">返回文字表达式</span></h2>

<p>请牢记，用&nbsp;<code>params =&gt; {object:literal}&nbsp;</code>这种简单的语法返回一个文字表达式是行不通的：</p>

<pre><code>
var func = () =&gt; {  foo: 1  };
// undefined!

var func = () =&gt; {  foo: function() {}  };
// SyntaxError: function statement requires a name（未定义函数语句）</code></pre>

<p>这是因为花括号（即&nbsp;<code>{}</code> ）里面的代码被解析为序列语句了（例如，&nbsp;<code>foo</code>&nbsp;被认为是一个标签, 而非文字表达式的组成部分）。</p>

<p>所以，记得用圆括号把文字表达式包起来：</p>

<pre><code>
var func = () =&gt; ({ foo: 1 });
</code>
</pre>

<h2 id="换行" class="highlight-spanned"><span class="highlight-span"><code>换行</code></span></h2>

<p>箭头函数在参数和箭头之间不能换行哦</p>

<pre><code>
var func = ()
           =&gt; 1; 
</code>
<code>// SyntaxError: expected expression, got '=&gt;'
</code></pre>

<h2 id="解析顺序" class="highlight-spanned"><span class="highlight-span">解析顺序</span></h2>

<p>在箭头函数中的箭头不是操作符(或者运算符,就像’+ -‘那些)，&nbsp;但是箭头函数有特殊的解析规则就是：相比普通的函数，受操作符的优先级影响。</p>

<pre><code>let callback;

callback = callback || function() {}; 
// ok
callback = callback || () =&gt; {};      
// SyntaxError:非法箭头函数属性
callback = callback || (() =&gt; {});    
// ok</code></pre>

<h3 id="sect1">&nbsp;</h3>

<h2 id="示例" class="highlight-spanned"><span class="highlight-span">示例</span></h2>

<pre class="brush: js"><span class="co1">// 一个空箭头函数,返回 undefined</span>
<code>
let empty = () =&gt; {};

(() =&gt; "foobar")(); 
// ES6 IIFE, 返回 "foobar" 

var simple = a =&gt; a &gt; 15 ? 15 : a; 
simple(16); // 15
simple(10); // 10

let max = (a, b) =&gt; a &gt; b ? `a bigger `: `b bigger`;

// 简单的数组筛选（数组filter方法），运算（数组map方法）, ...

var arr = [5, 6, 13, 0, 1, 18, 23];
var sum = arr.reduce((a, b) =&gt; a + b);  
// 66
var even = arr.filter(v =&gt; v % 2 == 0);
 // [6, 0, 18] 
var double = arr.map(v =&gt; v * 2);       
// [10, 12, 26, 0, 2, 36, 46] 
</code>

<code>// 更简明的promise链

promise.then(a =&gt; {
  // ...
}).then(b =&gt; {
   // ...
});</code>
</pre>

<pre class="brush: js"><code>// 更易理解的无参数箭头函数
setTimeout( () =&gt; {
  console.log('I happen sooner');
  setTimeout( () =&gt; {
    // deeper code
    console.log('I happen later');
  }, 1);
}, 1);</code></pre>

<p>&nbsp;</p>

<h2 id="规范" class="highlight-spanned"><span class="highlight-span">规范</span></h2>

<table class="standard-table"><br> <tbody><br>  <tr><br>   <th scope="col">Specification</th><br>   <th scope="col">Status</th><br>   <th scope="col">Comment</th><br>  </tr><br>  <tr><br>   <td><a lang="en" hreflang="en" href="http://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions" class="external external-icon" target="_blank" rel="external">ECMAScript 2015 (6th Edition, ECMA-262)<br><small lang="zh-CN">Arrow Function Definitions</small></a></td><br>   <td><span class="spec-Standard">Standard</span></td><br>   <td>Initial definition.</td><br>  </tr><br>  <tr><br>   <td><a lang="en" hreflang="en" href="https://tc39.github.io/ecma262/#sec-arrow-function-definitions" class="external external-icon" target="_blank" rel="external">ECMAScript Latest Draft (ECMA-262)<br><small lang="zh-CN">Arrow Function Definitions</small></a></td><br>   <td><span class="spec-Living">Living Standard</span></td><br>   <td>&nbsp;</td><br>  </tr><br> </tbody><br></table>

<h2 id="Browser_Compatibility" name="Browser_Compatibility" class="highlight-spanned"><span class="highlight-span">浏览器兼容性</span></h2>

<div><br><p></p><div class="htab"><br>    <a id="AutoCompatibilityTable" name="AutoCompatibilityTable"></a><br>    <ul><br>        <li class="selected"><a>Desktop</a></li><br>        <li><a>Mobile</a></li><br>    </ul><br></div><p></p><br><br><table><br> <tbody><br>  <tr><br>   <th>Feature</th><br>   <th>Chrome</th><br>   <th>Firefox (Gecko)</th><br>   <th>Edge</th><br>   <th>IE</th><br>   <th>Opera</th><br>   <th>Safari</th><br>  </tr><br>  <tr><br>   <td>Basic support</td><br>   <td>45.0</td><br>   <td><a title="Released on 2013-06-25." href="/en-US/Firefox/Releases/22">22.0</a> (22.0)</td><br>   <td><span style="color: #888;" title="Please update this with the earliest version of support.">(Yes)</span></td><br>   <td><br>    <p><span style="color: #f00;">未实现</span></p><br>   </td><br>   <td>32</td><br>   <td>10.0</td><br>  </tr><br>  <tr><br>   <td>Trailing comma in parameters</td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>   <td><a title="Released on 2017-03-07." href="/en-US/Firefox/Releases/52">52.0</a> (52.0)</td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>  </tr><br> </tbody><br></table><br><br><table><br> <tbody><br>  <tr><br>   <th>Feature</th><br>   <th>Android</th><br>   <th>Android Webview</th><br>   <th>Firefox Mobile (Gecko)</th><br>   <th>IE Mobile</th><br>   <th>Opera Mobile</th><br>   <th>Safari Mobile</th><br>   <th>Chrome for Android</th><br>  </tr><br>  <tr><br>   <td>Basic support</td><br>   <td><span style="color: #f00;">未实现</span></td><br>   <td>45.0</td><br>   <td>22.0 (22.0)</td><br>   <td><span style="color: #f00;">未实现</span></td><br>   <td><span style="color: #f00;">未实现</span></td><br>   <td>10.0</td><br>   <td>45.0</td><br>  </tr><br>  <tr><br>   <td>Trailing comma in parameters</td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>   <td>52.0 (52.0)</td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td><br>  </tr><br> </tbody><br></table><br></div>

<h2 id="sect2" class="highlight-spanned"><span class="highlight-span">&nbsp;</span></h2>

<h2 id="火狐规范注意事项" class="highlight-spanned"><span class="highlight-span">火狐规范注意事项</span></h2>

<ul><br> <li>在Firefox中使用箭头函数会自动添加严格模式。但是在Firefox 24开始后使用箭头函数时浏览器不在自动添加严格模式，若要使用需要手动声明。</li><br> <li>箭头函数和非标准语义不同&nbsp;<a title="表达式闭包是定义简单函数的一种便捷方式。" href="/zh-CN/docs/Web/JavaScript/Reference/Operators/Expression_Closures">expression closures</a> 添加了&nbsp;<a href="https://developer.mozilla.org/en-US/Firefox/Releases/3" target="_blank" rel="external">Firefox 3</a>&nbsp;(细节:&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.8" target="_blank" rel="external">JavaScript 1.8</a>) &nbsp;for <a title="表达式闭包是定义简单函数的一种便捷方式。" href="/zh-CN/docs/Web/JavaScript/Reference/Operators/Expression_Closures">expression closures</a> 不在词法上绑定this</li><br> <li>在Firefox 39之前，箭头函数的参数后不被允许添加换行符的(/n)。这是不符合ES6规范的有时候会像这样的代码&nbsp;<code>() \n =&gt; {}，在以后的版本中会报</code><a title="SyntaxError&nbsp;对象代表尝试解析语法上不合法的代码的错误。" href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"><code>SyntaxError</code></a></li><br></ul>

<h2 id="相关链接" class="highlight-spanned"><span class="highlight-span">相关链接</span></h2>

<ul><br> <li><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/" class="external external-icon" target="_blank" rel="external">“ES6 In Depth: Arrow functions” on hacks.mozilla.org</a></li><br> <li><a href="https://gist.github.com/xgqfrms-GitHub/43f021cd194c792c9cac504a071f741a" class="external external-icon" target="_blank" rel="external">demo</a></li><br></ul>





</article>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/javascript中作用域链和执行环境的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/javascript中作用域链和执行环境的理解/" itemprop="url">javascript中作用域链和执行环境的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T17:00:04+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h2><p><strong>执行环境的概念</strong>：每个函数在调用的时候会创建一个自己的执行环境。当执行流进入一个函数的时候，函数的环境就会被推入一个环境栈，而在函数执行之后，栈将其执行环境弹出，并将控制权移交给之前的执行环境。执行环境定义了变量和函数有权访问的其他数据，并定义了他们各自的行为；</p>
<p><strong>变量对象</strong>：当函数被调用的时候，每个执行环境都会有一个与之相关的变量对象，环境中定义的所有变量和对象都保存在这个对象。</p>
<p>变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 它是一个抽象的概念，不同的上下文中，它表示使用不同的object。例如，在global全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。</p>
<p><strong>作用域链</strong>：在一个函数被创建的时候，会创建一个预先包含全局变量对象的作用域链，并把这个作用域链保存于内部的【Scope】属性中；所以说创建任何一个函数的时候就会创建包含全局变量对象的作用域链；<br>当函数第一次被调用的时候，会创建一个执行环境以及相应的作用域链，然后通过复制函数的【scope】属性中的对象构建起执行环境的作用域链，然后又有一个活动对象（这里作为变量对象）被创建并被推入执行环境作用域链的前端，最后使用this，arguments，和其他命名参数来初始化函数活动对象（如果是函数，则将其活动对象作为变量对象）；</p>
<p><strong>性质</strong>：1，作用域链的前端始终都是当前执行代码所在环境的变量对象<br>            2，全局执行环境的的变量对象之中都是作用域链的最后一个变量对象；<br>            3，作用域链的作用在于保证对执行环境中有权访问的所有变量和函数的顺序访问；<br>            4，内部环境变量可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境的任何变量和函数；<br>            5，作用域链本质是一个指向变量对象的指针列表，他只引用但不实际包含变量对象。</p>
<p>度娘精选：<br><strong>执行上下文栈</strong>：注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。</p>
<p>一系列活动的执行上下文从逻辑上形成一个栈。<strong>栈底总是全局上下文</strong>，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。</p>
<p>当javascript代码文件被浏览器载入后，默认最先进入的是一个<strong>全局的执行上下文</strong>。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。</p>
<p><strong>执行上下文</strong>：也称为执行环节，一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。主要有三个属性：变量对象(variable object)，this指针(this value)，作用域链(scope chain)。</p>
<p><strong>活动对象</strong><br>当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。</p>
<p>即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象arguments 。</p>
<p><strong>作用域链优化</strong>：　从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/事件委托和事件代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/事件委托和事件代理/" itemprop="url">事件代理和事件委托</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T16:59:46+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如今的JavaScript技术界里最火热的一项技术应该是‘事件委托(event delegation)’了。使用事件委托技术能让你避免对特定的每个节点添加事件监听器；相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。基本概念非常简单，但仍有很多人不理解事件委托的工作原理。这里我将要解释事件委托是如何工作的，并提供几个纯JavaScript的基本事件委托的例子。</p>
<p>假定我们有一个UL元素，它有几个子元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=&quot;parent-list&quot;&gt;</div><div class="line">	&lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt;</div><div class="line">	&lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt;</div><div class="line">	&lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt;</div><div class="line">	&lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt;</div><div class="line">	&lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt;</div><div class="line">	&lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>我们还假设，当每个子元素被点击时，将会有各自不同的事件发生。你可以给每个独立的li元素添加事件监听器，但有时这些li元素可能会被删除，可能会有新增，监听它们的新增或删除事件将会是一场噩梦，尤其是当你的监听事件的代码放在应用的另一个地方时。但是，如果你将监听器安放到它们的父元素上呢？你如何能知道是那个子元素被点击了？</p>
<p>简单：当子元素的事件冒泡到父ul元素时，你可以检查事件对象的target属性，捕获真正被点击的节点元素的引用。下面是一段很简单的JavaScript代码，演示了事件委托的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 找到父元素，添加监听器...</div><div class="line">document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;,function(e) &#123;</div><div class="line">	// e.target是被点击的元素!</div><div class="line">	// 如果被点击的是li元素</div><div class="line">	if(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;) &#123;</div><div class="line">		// 找到目标，输出ID!</div><div class="line">		console.log(&quot;List item &quot;,e.target.id.replace(&quot;post-&quot;),&quot; was clicked!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第一步是给父元素添加事件监听器。当有事件触发监听器时，检查事件的来源，排除非li子元素事件。如果是一个li元素，我们就找到了目标！如果不是一个li元素，事件将被忽略。这个例子非常简单，UL和li是标准的父子搭配。让我们试验一些差异比较大的元素搭配。假设我们有一个父元素div，里面有很多子元素，但我们关心的是里面的一个带有”classA” CSS类的A标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 获得父元素DIV, 添加监听器...</div><div class="line">document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;,function(e) &#123;</div><div class="line">	// e.target是被点击的元素</div><div class="line">	if(e.target &amp;&amp; e.target.nodeName == &quot;A&quot;) &#123;</div><div class="line">		// 获得CSS类名</div><div class="line">		var classes = e.target.className.split(&quot; &quot;);</div><div class="line">		// 搜索匹配!</div><div class="line">		if(classes) &#123;</div><div class="line">			// For every CSS class the element has...</div><div class="line">			for(var x = 0; x &lt; classes.length; x++) &#123;</div><div class="line">				// If it has the CSS class we want...</div><div class="line">				if(classes[x] == &quot;classA&quot;) &#123;</div><div class="line">					// Bingo!</div><div class="line">					console.log(&quot;Anchor element clicked!&quot;);</div><div class="line"></div><div class="line">					// Now do something here....</div><div class="line"></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过上面的介绍，大家应该能够体会到使用事件委托对于web应用程序带来的几个优点：</p>
<p>1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。</p>
<p>2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。</p>
<p>3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。</p>
<p>写到这里，突然想起了之前对于Dojo DataGrid的困惑：那么多的rows和cells，如何处理他们事件之间的关系。现在想想，使用委托就很简单了。所有的事件委托到grid最外层的节点上，当事件发生的时候通过一些方法来获取和添加事件的额外属性，如rowIndex, cellIndex，之后在分配到onRowClick,onCellClick之类的处理函数上。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/javascript中线程和定时器的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/javascript中线程和定时器的理解/" itemprop="url">javascript中set Timeout和set Interval之间的爱恨情仇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T16:59:32+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>javascript定时器是一个比较喜欢欺骗别人的东西，不按套路出牌<br>在之前的认知当中，我们都是认为javascript的定时器是当运行到该定时器的执行代码的时候，该定时器的代码就会执行；但是你会发现；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div.onclick = function()&#123;</div><div class="line">　　setTimeout(function() &#123;</div><div class="line"> 　　     document.getElementById(&apos;inputField&apos;).focus();</div><div class="line"> 　　&#125;, 0);</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>突然出现了一个间隔时间为0，很蒙圈，那还需要定时器有什么用呢；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">setTimeout(function() &#123;</div><div class="line"></div><div class="line">　　while (true) &#123;</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　&#125;, 100);</div><div class="line"></div><div class="line">　　setTimeout(function() &#123;</div><div class="line"></div><div class="line">　　     alert(&apos;你好!&apos;);</div><div class="line"></div><div class="line">　　&#125;, 200);</div><div class="line"></div><div class="line">　　setInterval(callbackFunction, 200);</div></pre></td></tr></table></figure>
<p>在这里，你发现第一个定时器中的循环让代码出现要给死循环；之后应该运行alert和callbackFn，但是事实上这两个都没有如期出现；javascript定时器很让人着迷啊；</p>
<p>   <strong>事实在于:javascript中，程序都是单线程运行的，浏览器不管在什么时候始终都只有一个线程在运行javascript程序；javascript是单线程运用；</strong></p>
<p>那么浏览器又是如何处理单线程问题的呢？<br>     在浏览器中允许多个线程异步执行，这些线程在内核的控制下相互配合有保持同步；对于浏览器中的js引擎来说，它是基于事件驱动的，从代码的角度来说，各种任务都是回掉函数，javascript引擎一直在等待着事件任务队列中任务的到来；由于javascript是单线程运行的，所有处在队列中的事件需要排队等候；一个一个被浏览器所执行；</p>
<p> <strong>js定时触发的线程：</strong><br>          注意这里的浏览器模型定时计数器并不是由JavaScript引擎计数的,因为JavaScript引擎是单线程的,如果处于阻塞线程状态就计不了时,它必须依赖外部来计时并触发定时,所以队列中的定时事件也是异步事件.</p>
<p>　　由图可知,在这t1的时间段内,继鼠标点击事件触发后,先前已设置的setTimeout定时也到达了,此刻对JavaScript引擎来说,定时触发线程产生了一个异步定时事件并放到任务队列中, 该事件被排到点击事件回调之后,等待处理.</p>
<p>　　同理, 还是在t1时间段内,接下来某个setInterval定时器也被添加了,由于是间隔定时,在t1段内连续被触发了两次,这两个事件被排到队尾等待处理.</p>
<p>　　可见,假如时间段t1非常长,远大于setInterval的定时间隔,那么定时触发线程就会源源不断的产生异步定时事件并放到任务队列尾而不管它们是否已被处理,但一旦t1和最先的定时事件前面的任务已处理完,这些排列中的定时事件就依次不间断的被执行,这是因为,对于JavaScript引擎来说,在处理队列中的各任务处理方式都是一样的,只是处理的次序不同而已.</p>
<p>　　t1过后,也就是说当前处理的任务已返回,JavaScript引擎会检查任务队列,发现当前队列非空,就取出t2下面对应的任务执行,其它时间依此类推,由此看来:</p>
<p><strong>javascript的单线程：如果队列非空,引擎就从队列头取出一个任务,直到该任务处理完,即返回后引擎接着运行下一个任务,在任务没返回前队列中的其它任务是没法被执行的.</strong><br>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<p>如果你在javascript代码中插入一个setTimeout，并且设置时间为0；只是代表这个任务会被立刻插入到队列中，但不是立即执行；所以javascript中的定时器可能会出现不按预想中的那样执行的效果；<br>一般来说定时器是最后执行的代码；<br><strong>定时器最重要的是： 指定的时间间隔表示何时将定时器的代码添加到队列中，而不是何时执行代码；</strong><br>      当使用setInterval时，仅当没有定时器的任何其它代码时，才将定时器代码添加到队列中，这样会确保定时器代码加入到队列的时间的间隔是为指定的间隔，请注意这只是加入队列的时间间隔，并不是执行代码的时间间隔，所以使用setInterval还是会存在两个问题：<br>     <strong>（1）某些间隔会被跳过了</strong><br>      <strong>（2）多个定时器的代码执行间隔可能会比预期的要小。</strong><br>     注意：最好不要使用setInterval，尽量使用setTimeout的延时递归来代替setInterval<br>     因为使用setInterval来进行回掉容易产生回掉堆积，特别是时间非常短的时候；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Timer() &#123;</div><div class="line">  this.s1 = 0;</div><div class="line">  this.s2 = 0;</div><div class="line">  // 箭头函数</div><div class="line">  setInterval(() =&gt; this.s1++, 1000);</div><div class="line">  // 普通函数</div><div class="line">  setInterval(function () &#123;</div><div class="line">  this.s2++;</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var timer = new Timer();</div><div class="line"></div><div class="line">setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3000);</div><div class="line">setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3000);</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/闭包的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/闭包的理解/" itemprop="url">javascript中闭包的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T16:57:01+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>闭包</strong>：指有权访问另一个函数作用域中的变量的函数。</p>
<pre><code>闭包是指这样的作用域，它包含有一个函数，这个函数可以调用被这个作用域所封闭的变量、函数或者闭包等内容。通常我们通过闭包所对应的函数来获得对闭包的访问。
</code></pre><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function init() &#123;</div><div class="line">  let name = &quot;Mozilla&quot;; </div><div class="line">  // name 是一个被init创建的局部变量</div><div class="line">  function displayName() &#123; </div><div class="line">  // displayName() 是一个内部函数,</div><div class="line">      alert(name); </div><div class="line">      //  一个闭包使用在父函数中声明的变量</div><div class="line">      //注意，不要误认为闭包一定是被返回的函数，只要可以调用另外一个函数作用域的变量的函数就叫做闭包。</div><div class="line">  &#125; </div><div class="line">  displayName();</div><div class="line">&#125;</div><div class="line">init();</div></pre></td></tr></table></figure>
<p>函数 init() 创建了一个局部变量 name和一个名为 displayName() 的函数。 displayName() 是一个内部函数——定义于 init() 之内且仅在该函数体内可用。displayName() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数 init() 中声明的 name 变量。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function makeFunc() &#123;</div><div class="line">  var name = &quot;Mozilla&quot;;</div><div class="line">  function displayName() &#123;</div><div class="line">    alert(name);</div><div class="line">  &#125;</div><div class="line">  return displayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myFunc = makeFunc();</div><div class="line">myFunc();</div></pre></td></tr></table></figure>
<p>运行这段代码的效果和之前的 init() 示例完全一样：字符串 “Mozilla” 将被显示在一个 JavaScript 警告框中。其中的不同 — 也是有意思的地方 — 在于 displayName() 内部函数在执行前被从其外围函数中返回了。</p>
<p>这段代码看起来别扭却能正常运行。在一些编程语言中，函数中的局部变量仅在函数的执行期间可用。一旦 makeFunc() 执行过后，我们会很合理的认为 name 变量将不再可用。然而，因为代码运行的没问题，所以很显然在 JavaScript 中并不是这样的。</p>
<p>这个谜题的答案是 myFunc 变成一个 闭包 了。 闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 “Mozilla” 字符串形成。</p>
<h2 id="闭包的用处"><a href="#闭包的用处" class="headerlink" title="闭包的用处"></a>闭包的用处</h2><p>1，闭包可以访问当前函数以外的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function getOuter()&#123;</div><div class="line">  var date = &apos;815&apos;;</div><div class="line">  function getDate(str)&#123;</div><div class="line">    console.log(str + date);  //访问外部的date</div><div class="line">  &#125;</div><div class="line">  return getDate(&apos;今天是：&apos;); //&quot;今天是：815&quot;</div><div class="line">&#125;</div><div class="line">getOuter();</div><div class="line">getDate是一个闭包，该函数执行时，会形成一个作用域A，A中并没有定义变量date，但它能在父一级作用域中找到该变量的定义。</div></pre></td></tr></table></figure>
<p>2、即使外部函数已经返回，闭包仍能访问外部函数定义的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function getOuter()&#123;</div><div class="line">  var date = &apos;815&apos;;</div><div class="line">  function getDate(str)&#123;</div><div class="line">    console.log(str + date);  //访问外部的date</div><div class="line">  &#125;</div><div class="line">  return getDate;     //外部函数返回</div><div class="line">&#125;</div><div class="line">var today = getOuter();</div><div class="line">today(&apos;今天是：&apos;);   //&quot;今天是：815&quot;</div><div class="line">today(&apos;明天不是：&apos;);   //&quot;明天不是：815&quot;</div></pre></td></tr></table></figure>
<p>3、闭包可以更新外部变量的值（模拟私有方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function updateCount()&#123;</div><div class="line">  var count = 0;</div><div class="line">  function getCount(val)&#123;</div><div class="line">    count = val;</div><div class="line">    console.log(count);</div><div class="line">  &#125;</div><div class="line">  return getCount;     //外部函数返回</div><div class="line">&#125;</div><div class="line">var count = updateCount();</div><div class="line">count(815); //815</div><div class="line">count(816); //816</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/JS 中setTimeout和set Interval之间的爱恨情仇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/JS 中setTimeout和set Interval之间的爱恨情仇/" itemprop="url">setTimeout和setInterval之间的爱恨情仇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T16:55:07+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在说起javascript中定时器的问题，需要事先明确这样几个概念：</p>
<p>1，setTimeout：setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式,<br>2，setInterval:  setInterval()则是在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除；<br>3，clearInterval: setInterval定时器在执行之后会返回一个对应的定时器ID，可以通过clearInterval（ID）删除定时器的执行<br>4，clearTimeout： set Timeout定时器在执行之后也会返回一个对应的定时器ID，通过clearTimeout就可以删除对应的定时器执行</p>
<h2 id="JS中的事件循环机制机制："><a href="#JS中的事件循环机制机制：" class="headerlink" title="JS中的事件循环机制机制："></a>JS中的事件循环机制机制：</h2><p>浏览器（或者说JS引擎）执行JS的机制是基于事件循环。<br>由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。</p>
<p>同步任务直接在主线程队列中顺序执行，而<strong>异步任务会进入另一个任务队列，不会阻塞主线程</strong>。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。</p>
<p>在JS中，这个任务队列是一个包含各种消息的消息队列，这些消息就是注册异步事件的时候添加的回掉函数；  然而JS主线程只负责一件事情，那就是从消息队列中取消息，执行消息，在取消息，执行消息；当消息队列为空的时候，就会等待消息队列为非空的时候取消息，而且主线程只有在当前的消息执行完毕之后才会去取下一个消息执行；这种机制就叫做事件循环机制，</p>
<h2 id="三、JS定时器的工作原理"><a href="#三、JS定时器的工作原理" class="headerlink" title="三、JS定时器的工作原理"></a>三、JS定时器的工作原理</h2><p>（扣别人的）</p>
<p>在解释上面问题的答案之前我们先来了解一下定时器的工作原理，这里将用引用How JavaScript Timers Work中的例子来解释定时器的工作原理，该图为一个简单版的原理图。<br><img src="http://img.blog.csdn.net/20170810143227974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzcwNTk0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="JS事件循环机制"></p>
<p>上图中，左侧数字代表时间，单位毫秒；左侧文字代表某一个操作完成后，浏览器去询问当前队列中存在哪些正在等待执行的操作；蓝色方块表示正在执行的代码块；右侧文字代表在代码运行过程中，出现哪些异步事件。该图大致流程如下：</p>
<p>程序开始时，有一个JS代码块开始执行，执行时长约为18ms，在执行过程中有3个异步事件触发，其中包括一个setTimeout、鼠标点击事件、setInterval<br>第一个setTimeout先运行，延迟时间为10ms，稍后鼠标事件出现，浏览器在事件队列中插入点击的回调函数，稍后setInterval运行，10ms到达之后，setTimeout向事件队列中插入setTimeout的回调<br>当第一个代码块执行完成后，浏览器查看队列中有哪些事件在等待，他取出排在队列最前面的代码来执行<br>在浏览器处理鼠标点击回调时，setInterval再次检查到到达延迟时间，他将再次向事件队列中插入一个interval的回调，以后每隔指定的延迟时间之后都会向队列中插入一个回调<br>后面浏览器将在执行完当前队头的代码之后，将再次取出目前队头的事件来执行<br>这里只是对定时器的原理做一个简单版的描述，实际的处理过程比这个复杂。</p>
<h2 id="定时器的用法："><a href="#定时器的用法：" class="headerlink" title="定时器的用法："></a>定时器的用法：</h2><p>setTimeOut用法<br>setTimeout函数的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var timeoutID = window.setTimeout(func, [delay, param1, param2, ...]); </div><div class="line">var timeoutID = window.setTimeout(code, [delay]); </div><div class="line">timeoutID：定时器ID号，它可以在clearTimeout()函数中被用来清除定时器。</div><div class="line"></div><div class="line">func：被执行的函数。</div><div class="line"></div><div class="line">code：（替代的语法）一个被执行的代码串。</div><div class="line"></div><div class="line">delay：延迟的时间，单位毫秒。如果没有指定，默认为0。</div></pre></td></tr></table></figure>
<p>我们可以使用window.setTimeout或setTimeout，两个写法基本一样，只不过window.setTimeout将setTimeout函数作为全局window对象的一个属性来引用。</p>
<p>应用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function timeout()&#123; </div><div class="line">    document.getElementById(&apos;res&apos;).innerHTML=Math.floor(Math.random()*100 + 1); </div><div class="line">&#125; </div><div class="line">setTimeout(&quot;timeout()&quot;,5000); </div><div class="line">代码执行时，5秒后调用timeout()函数</div></pre></td></tr></table></figure>
<p>setInterval用法<br>setInterval函数的参数及用法和setTimeout函数一样，请参照上文的setTimeout函数的用法介绍。不同的是，setInterval每隔一定的时间执行当中的func或code代码。</p>
<p>应用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var tt = 10; </div><div class="line">function timego()&#123; </div><div class="line">    tt--; </div><div class="line">    document.getElementById(&quot;tt&quot;).innerHTML = tt; </div><div class="line">    if(tt==0)&#123;  </div><div class="line">        window.location.href=&apos;/&apos;; </div><div class="line">        return false; </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">var timer = window.setInterval(&quot;timego()&quot;,1000);</div></pre></td></tr></table></figure>
<p>函数timego()定义了页面元素#tt显示的内容，当tt等于0时，页面定向到首页。然后我们定义一个定时器timer，使用setInterval()每隔1秒调用一次timego()。这样timego会执行10次，每次数字tt会减1，直到为0。那么如果想停止定时器，可以使用以下代码：</p>
<p>window.clearInterval(timer);  </p>
<h2 id="setTimeout和setnterval之间的区别："><a href="#setTimeout和setnterval之间的区别：" class="headerlink" title="setTimeout和setnterval之间的区别："></a>setTimeout和setnterval之间的区别：</h2><p>1，setTimeout在时间间隔之后将定时器插入到事件循环队列之中，若前面有执行时间较长的程序，可能会延迟执行；<br>2，set Interval按照时间间隔将定时器插入到循环队列之中，但是<strong>循环队列中某一时刻只能有一个定时器对象实例</strong>；因此在set Interval中存在以下两个问题：</p>
<p><strong>（1）某些间隔会被跳过；</strong><br><strong>（2）多个定时器的代码执行之间的间隔可能比预期的小；</strong><br>3， setTimeout和setInterval的作用只是把你要执行的代码在你设定的一个时间点插入到引擎维护的一个消息队列中, 插入消息队列并不意味着你的代码就会立马执行的,理解这一点很重要</p>
<p>对于set Timeout：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> function click() &#123; </div><div class="line">    // code block1... </div><div class="line">    setTimeout(function() &#123; </div><div class="line">    // process ... </div><div class="line">    &#125;, 200); </div><div class="line">    // code block2 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设我们给一个button的onclick事件绑定了此方法, 当我们按下按钮后, 肯定先执行block1的内容, 然后运行到setTimeout的地方, setTimeout会告诉浏览器说, “<strong>200ms后我会插一段要执行的代码给你的队列中</strong>“, 浏览器当然答应了(注意<strong>插入代码并不意味着立马执行</strong>), setTimeout代码运行后, 紧跟其后的block2代码开始执行, 这里就开始说明问题了, 如果block2的代码执行时间超过200ms, 那结果会是如何?</p>
<p>或许按照你之前的理解, 会理所当然的认为200ms一到, 你的process代码会立马执行…事实是, <strong>在block2执行过程中(执行了200ms后)process代码被插入代码队列, 但一直要等click方法执行结束, 才会执行process代码段,</strong> 从代码队列上看process代码是在click后面的, 再加上js以单线程方式执行, 所以应该不难理解.</p>
<p>如果是另一种情况, block2代码执行的时间&lt;200ms, setTimeout在200ms后将process代码插入到代码队列, 而那时执行线程可能已经处于空闲状态了(idle), 那结果就是200ms后, process代码插入队列就立马执行了, 就让你感觉200ms后, 就执行了.</p>
<p>再看看setInterval ：它存在两个问题<br>    <strong>（1）某些间隔会被跳过；</strong><br>    <strong>（2）多个定时器的代码执行之间的间隔可能比预期的小；</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function click() &#123; </div><div class="line">    // code block1... </div><div class="line">    setInterval(function() &#123; </div><div class="line">    // process ... </div><div class="line">    &#125;, 200); </div><div class="line">    // code block2 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和上面一样我们假设通过一个click, 触发了setInterval以实现每隔一个时间段执行process代码<br>这里写图片描述<br><img src="http://img.blog.csdn.net/20170810145354649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzcwNTk0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>比如onclick要300ms执行完, block1代码执行完, 在5ms时执行setInterval, 以此为一个时间点, 在205ms时插入process代码, click代码顺利结束, process代码开始执行(相当于图中的timer code), 然而process代码也执行了一个比较长的时间, 超过了接下来一个插入时间点405ms, 这样代码队列后又插入了一份process代码, process继续执行着, 而且超过了605ms这个插入时间点,</p>
<p>下面问题来, 可能你还会认为代码队列后面又会继续插入一份process代码…真实的情况是,由于代码队列中已经<strong>有了一份未执行的process代码</strong>, 所以<strong>605ms这个插入时间点将会被“无情”的跳过</strong>, 因为js引擎只允许有一份未执行的process代码, 这里我想我们都明白了JS引擎的小九九了吧…</p>
<p>4，内存泄漏问题：<br>内联书写setInterval时，由于匿名函数被定义于全局中，不能够计时器的清除，因此很容易造成内存泄露。</p>
<p>规避办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line"></div><div class="line">          // 其他代码</div><div class="line">          setTimeout(arguments.callee, interval);</div><div class="line">     &#125;, interval);</div></pre></td></tr></table></figure>
<pre><code>// 备注:interval指的是毫秒数。
// 基本原理是：链式的调用setTimeout，每次函数执行时会创建一个新的定时器，第二个setTimeout调用使用了arguments.callee来获取对当前执行的函数的引用，并为它设置另一个定时器。这样做的好处是，在前一个定时器代码执行完毕之后，不会在队列中加入新的定时器代码，同时还能够没有任何缺失的间隔，从而避免连续运行。callee 属性是 arguments 对象的一个成员，他表示对函数对象本身的引用，这有利于匿名函数的递归或确保函数的封装性
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/javascript中的内存泄漏问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/javascript中的内存泄漏问题/" itemprop="url">Javascript中内存泄漏的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T16:50:26+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内存泄漏是一个常见的性能问题，常常会导致程序的崩溃，运行缓慢，高延迟或者其他的一下问题；</p>
<h2 id="内存泄漏："><a href="#内存泄漏：" class="headerlink" title="内存泄漏："></a>内存泄漏：</h2><p>内存泄漏是指分配给应用的内存不能被重新分配，即使在内存已经不被使用的时候。正常情况下，垃圾回收器在DOM元素和event处理器不被引用或访问的时候回收它们。但是，IE的早些版本(IE7和之前)中内存泄漏是很容易出现的，因为内存管理器不能正确理解Javascript生命周期而且在周期被打破(可以通过赋值为null实现)前不会回收内存。</p>
<h2 id="Javascript-中的垃圾收集机制："><a href="#Javascript-中的垃圾收集机制：" class="headerlink" title="Javascript 中的垃圾收集机制："></a>Javascript 中的垃圾收集机制：</h2><p>javascript具有自动垃圾收集机制，也就是说，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理；垃圾收集器会按照固定的时间间隔，周期性的执行这一操作；<br>        javascript中有两种垃圾回收方法：标记清除，引用计数；</p>
<h2 id="javascript中内存泄漏的几种方式"><a href="#javascript中内存泄漏的几种方式" class="headerlink" title="javascript中内存泄漏的几种方式"></a>javascript中内存泄漏的几种方式</h2><p><strong>1，意外的全局变量</strong><br>JavaScript 宽容性的一点表现在它处理未声明变量的方式上：一个未声明变量的引用会在全局对象中创建一个新的变量。在浏览器的环境下，全局对象就是 window</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	function leaks()&#123;  </div><div class="line">    leak = &apos;xxxxxx&apos;;//leak 成为一个全局变量，不会被回收</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种意外全局变量被创建的方式是通过this：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    this.str= &quot;this is a global&quot;;</div><div class="line">&#125;</div><div class="line">//在这里str也是一个全局变量，只不过比较隐晦罢了</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>为了阻止这种错误发生，在你的Javascript文件最前面添加’use strict;’。这开启了解析JavaScript的阻止意外全局的更严格的模式。</p>
<p><strong>2，闭包引起的内存泄漏</strong><br>闭包可以导致内存泄漏是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了内部方法还可以继续访问在外部方法中定义的私有变量。对Javascript程序员来说最好的做法是在页面重载前断开所有的事件处理器。<br>var getBIBAO= (function(){<br>    var leak = ‘1234567’;// 被闭包所引用，不会被回收<br>    return function(){<br>        console.log(leak);<br>    }<br>})()<br>1234567</p>
<p><strong>3，循环引用</strong><br>简单来说假如a引用了b,b又引用了a,a和b就构成了循环a和b循环引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var a=new Object;</div><div class="line"></div><div class="line">var b=new Object;</div><div class="line"></div><div class="line">a.r=b;</div><div class="line"></div><div class="line">b.r=a;</div><div class="line"></div><div class="line">a循环引用自己：</div><div class="line"></div><div class="line">var a=new Object;</div><div class="line"></div><div class="line">a.r=a;</div></pre></td></tr></table></figure></p>
<p>用很常见且大部分情况下是无害的，但当参与循环引用的对象中有DOM对象或者ActiveX对象时，循环引用将导致内存泄露。我们把例子中的任何一个new Object替换成document.getElementById或者document.createElement就会发生内存泄露了。</p>
<p><strong>4,dom清空或删除时，事件未清除导致的内存泄漏</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;container&quot;&gt;  </div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</div><div class="line">    console.log(&apos;click&apos;);</div><div class="line">&#125;).remove();</div><div class="line"></div><div class="line">// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题</div><div class="line">12345678</div><div class="line">&lt;div id=&quot;container&quot;&gt;  </div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</div><div class="line">    console.log(&apos;click&apos;);</div><div class="line">&#125;).off(&apos;click&apos;).remove();</div><div class="line">//把事件清除了，即可从内存中移除</div><div class="line">1234567</div></pre></td></tr></table></figure>
<p>5，被遗忘的定时器或者回掉<br>在javascript中，使用set Interval之后，不把这个清除掉容易产生内存泄漏的问题；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var someResource = getData();</div><div class="line">setInterval(function() &#123;</div><div class="line">    var node = document.getElementById(&apos;Node&apos;);</div><div class="line">    if(node) &#123;</div><div class="line">        // Do stuff with node and someResource.</div><div class="line">        node.innerHTML = JSON.stringify(someResource));</div><div class="line">    &#125;</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>这个例子表明了跳动的计时器可能发生什么：计时器使得节点或数据的引用不再被需要了。代表node的对象将来可能被移除，使得整个块在间隔中的处理不必要。然而，处理函数，由于间隔仍然是活跃的，不能被回收（间隔需要被停掉才能回收）。如果间隔处理不能被回收，它的依赖也不能被回收。那意味着可能存储着大量数据的someResource，也不能被回收。</p>
<p>6，由于子元素的存在引起的内存泄漏问题<br><img src="http://img.blog.csdn.net/20170810160025725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzcwNTk0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li>黄色是指直接被 js变量所引用，在内存里</li>
<li>红色是指间接被 js变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的</li>
<li>子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/09/作用域链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/09/作用域链/" itemprop="url">javascript作用域链和执行环境的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T15:38:08+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h2><p><strong>执行环境的概念</strong>：每个函数在调用的时候会创建一个自己的执行环境。当执行流进入一个函数的时候，函数的环境就会被推入一个环境栈，而在函数执行之后，栈将其执行环境弹出，并将控制权移交给之前的执行环境。执行环境定义了变量和函数有权访问的其他数据，并定义了他们各自的行为；</p>
<p><strong>变量对象</strong>：当函数被调用的时候，每个执行环境都会有一个与之相关的变量对象，环境中定义的所有变量和对象都保存在这个对象。</p>
<p>变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 它是一个抽象的概念，不同的上下文中，它表示使用不同的object。例如，在global全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。</p>
<p><strong>作用域链</strong>：在一个函数被创建的时候，会创建一个预先包含全局变量对象的作用域链，并把这个作用域链保存于内部的【Scope】属性中；所以说创建任何一个函数的时候就会创建包含全局变量对象的作用域链；<br>当函数第一次被调用的时候，会创建一个执行环境以及相应的作用域链，然后通过复制函数的【scope】属性中的对象构建起执行环境的作用域链，然后又有一个活动对象（这里作为变量对象）被创建并被推入执行环境作用域链的前端，最后使用this，arguments，和其他命名参数来初始化函数活动对象（如果是函数，则将其活动对象作为变量对象）；</p>
<p><strong>性质</strong>：1，作用域链的前端始终都是当前执行代码所在环境的变量对象<br>            2，全局执行环境的的变量对象之中都是作用域链的最后一个变量对象；<br>            3，作用域链的作用在于保证对执行环境中有权访问的所有变量和函数的顺序访问；<br>            4，内部环境变量可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境的任何变量和函数；<br>            5，作用域链本质是一个指向变量对象的指针列表，他只引用但不实际包含变量对象。</p>
<p>度娘精选：<br><strong>执行上下文栈</strong>：注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。</p>
<p>一系列活动的执行上下文从逻辑上形成一个栈。<strong>栈底总是全局上下文</strong>，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。</p>
<p>当javascript代码文件被浏览器载入后，默认最先进入的是一个<strong>全局的执行上下文</strong>。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。</p>
<p><strong>执行上下文</strong>：也称为执行环节，一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。主要有三个属性：变量对象(variable object)，this指针(this value)，作用域链(scope chain)。</p>
<p><strong>活动对象</strong><br>当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。</p>
<p>即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象arguments 。</p>
<p><strong>作用域链优化</strong>：　从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/27/binary_tree_traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="闻国龙">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wenguolong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/27/binary_tree_traversal/" itemprop="url">二叉树三种遍历的非递归思路（JAVASCRIPT)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-27T15:39:26+08:00">
                2017-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/树/" itemprop="url" rel="index">
                    <span itemprop="name">树</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>二叉树在图论中是这样定义的：二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。然而，没有足够的信息来区分左结点和右结点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。</p>
<p>这里，我使用javascript来写二叉树遍历的三种非递归方式，因为楼主学的是javascript，对于C，JAVA，C++这个都不是很熟，所以就只好使用javascript代替；</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><pre><code>第一种方法
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var preorderTraversal = function(root) &#123;</div><div class="line">    var stack = [];</div><div class="line">    var res = [];</div><div class="line">    </div><div class="line">    var p = root;</div><div class="line">    if(root == null)return [];</div><div class="line"></div><div class="line">    while(stack.length!=0 || p!=null)&#123;</div><div class="line">//Side by side to join the array, and deposited in the stack, the future need to use these root nodes  into the right sub-tree</div><div class="line">        while(p!=null)&#123;</div><div class="line">            stack.push(p);</div><div class="line">            res.push(p.val);</div><div class="line">            p = p.left;</div><div class="line">        &#125;</div><div class="line">      //  When p is empty, it means that both the root and the left subtree are traversed, and the right tree goes</div><div class="line">        if(stack.length!=0)&#123;</div><div class="line">            p = stack.pop();</div><div class="line">            p = p.right;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return res;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第二种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var preorderTraversal = function(root) &#123;</div><div class="line">  var result = [];</div><div class="line">  var stack = [];</div><div class="line">  var p = root;</div><div class="line">  while(stack.length!=0 || p != null) &#123;</div><div class="line">	  if(p != null) &#123;</div><div class="line">		  stack.push(p);</div><div class="line">		  result.push(p.val); // Add before going to children</div><div class="line">		  p = p.left;</div><div class="line">	  &#125; else &#123;</div><div class="line">		  var node = stack.pop();</div><div class="line">		  p = node.right;</div><div class="line">	  &#125;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>第一种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var inorderTraversal = function(root) &#123;</div><div class="line">  var stack = [];</div><div class="line">  var res = [];</div><div class="line">  var p = root;</div><div class="line">  if(root == null) return [];</div><div class="line"></div><div class="line">  while( stack.length!=0 || p!=null)&#123;</div><div class="line"></div><div class="line">	  while(p!=null)&#123;</div><div class="line">		  stack.push(p);</div><div class="line">		  p = p.left;</div><div class="line">	  &#125;</div><div class="line">	</div><div class="line">	  if(stack.length!=0)&#123;</div><div class="line">		  p= stack.pop();</div><div class="line">		  res.push(p.val);</div><div class="line">		  p = p.right;</div><div class="line">	  &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return res;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第二种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var inorderTraversal = function(root) &#123;</div><div class="line">  var result = [];</div><div class="line">  var stack = [];</div><div class="line">  var p = root;</div><div class="line">  while(stack.length!=0 || p != null) &#123;</div><div class="line">	  if(p != null) &#123;</div><div class="line">	  stack.push(p);</div><div class="line">	  p = p.left;</div><div class="line">  &#125; else &#123;</div><div class="line">	  var node = stack.pop();</div><div class="line">	  result.push(node.val); // Add after all left children</div><div class="line">	  p = node.right;</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>第一种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var postorderTraversal = function(root) &#123;</div><div class="line">  var Stack = [];</div><div class="line">    var result = [];</div><div class="line">     </div><div class="line">    if(root==null)</div><div class="line">        return [];</div><div class="line">    </div><div class="line">    Stack.push(root);</div><div class="line">    while(Stack.length!=0)</div><div class="line">    &#123;</div><div class="line">      var node= Stack.pop();</div><div class="line">        result.push(node.val);</div><div class="line">        </div><div class="line">        </div><div class="line">        if(node.left)</div><div class="line">        Stack.push(node.left);</div><div class="line">        </div><div class="line">        if(node.right)</div><div class="line">        Stack.push(node.right);</div><div class="line">      </div><div class="line">    &#125;</div><div class="line">    return result.reverse();</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第二种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var postorderTraversal = function(root) &#123;</div><div class="line">  var result = [];</div><div class="line">  var stack = [];</div><div class="line">  var p = root;</div><div class="line">  while(stack.length!=0 || p != null) &#123;</div><div class="line">  if(p != null) &#123;</div><div class="line">  stack.push(p);</div><div class="line">  result.unshift(p.val); // Reverse the process of preorder</div><div class="line">  p = p.right; // Reverse the process of preorder</div><div class="line">  &#125; else &#123;</div><div class="line">  var node = stack.pop();</div><div class="line">  p = node.left; // Reverse the process of preorder</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="闻国龙" />
          <p class="site-author-name" itemprop="name">闻国龙</p>
           
              <p class="site-description motion-element" itemprop="description">welcome to my blog!!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">闻国龙</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "66e57368afc840a395847ec566bfdb38",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
