<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript中作用域链和执行环境的理解]]></title>
    <url>%2F2017%2F08%2F12%2Fjavascript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[个人理解：执行环境的概念：每个函数在调用的时候会创建一个自己的执行环境。当执行流进入一个函数的时候，函数的环境就会被推入一个环境栈，而在函数执行之后，栈将其执行环境弹出，并将控制权移交给之前的执行环境。执行环境定义了变量和函数有权访问的其他数据，并定义了他们各自的行为； 变量对象：当函数被调用的时候，每个执行环境都会有一个与之相关的变量对象，环境中定义的所有变量和对象都保存在这个对象。 变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 它是一个抽象的概念，不同的上下文中，它表示使用不同的object。例如，在global全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。 作用域链：在一个函数被创建的时候，会创建一个预先包含全局变量对象的作用域链，并把这个作用域链保存于内部的【Scope】属性中；所以说创建任何一个函数的时候就会创建包含全局变量对象的作用域链；当函数第一次被调用的时候，会创建一个执行环境以及相应的作用域链，然后通过复制函数的【scope】属性中的对象构建起执行环境的作用域链，然后又有一个活动对象（这里作为变量对象）被创建并被推入执行环境作用域链的前端，最后使用this，arguments，和其他命名参数来初始化函数活动对象（如果是函数，则将其活动对象作为变量对象）； 性质：1，作用域链的前端始终都是当前执行代码所在环境的变量对象 2，全局执行环境的的变量对象之中都是作用域链的最后一个变量对象； 3，作用域链的作用在于保证对执行环境中有权访问的所有变量和函数的顺序访问； 4，内部环境变量可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境的任何变量和函数； 5，作用域链本质是一个指向变量对象的指针列表，他只引用但不实际包含变量对象。 度娘精选：执行上下文栈：注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。 一系列活动的执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。 当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。 执行上下文：也称为执行环节，一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。主要有三个属性：变量对象(variable object)，this指针(this value)，作用域链(scope chain)。 活动对象当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。 即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象arguments 。 作用域链优化： 从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件代理和事件委托]]></title>
    <url>%2F2017%2F08%2F12%2F%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[如今的JavaScript技术界里最火热的一项技术应该是‘事件委托(event delegation)’了。使用事件委托技术能让你避免对特定的每个节点添加事件监听器；相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。基本概念非常简单，但仍有很多人不理解事件委托的工作原理。这里我将要解释事件委托是如何工作的，并提供几个纯JavaScript的基本事件委托的例子。 假定我们有一个UL元素，它有几个子元素： 12345678&lt;ul id=&quot;parent-list&quot;&gt; &lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt; &lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt; &lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt; &lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt; &lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt; &lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt; 我们还假设，当每个子元素被点击时，将会有各自不同的事件发生。你可以给每个独立的li元素添加事件监听器，但有时这些li元素可能会被删除，可能会有新增，监听它们的新增或删除事件将会是一场噩梦，尤其是当你的监听事件的代码放在应用的另一个地方时。但是，如果你将监听器安放到它们的父元素上呢？你如何能知道是那个子元素被点击了？ 简单：当子元素的事件冒泡到父ul元素时，你可以检查事件对象的target属性，捕获真正被点击的节点元素的引用。下面是一段很简单的JavaScript代码，演示了事件委托的过程： 123456789// 找到父元素，添加监听器...document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;,function(e) &#123; // e.target是被点击的元素! // 如果被点击的是li元素 if(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;) &#123; // 找到目标，输出ID! console.log(&quot;List item &quot;,e.target.id.replace(&quot;post-&quot;),&quot; was clicked!&quot;); &#125;&#125;); 第一步是给父元素添加事件监听器。当有事件触发监听器时，检查事件的来源，排除非li子元素事件。如果是一个li元素，我们就找到了目标！如果不是一个li元素，事件将被忽略。这个例子非常简单，UL和li是标准的父子搭配。让我们试验一些差异比较大的元素搭配。假设我们有一个父元素div，里面有很多子元素，但我们关心的是里面的一个带有”classA” CSS类的A标记： 1234567891011121314151617181920212223// 获得父元素DIV, 添加监听器...document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;,function(e) &#123; // e.target是被点击的元素 if(e.target &amp;&amp; e.target.nodeName == &quot;A&quot;) &#123; // 获得CSS类名 var classes = e.target.className.split(&quot; &quot;); // 搜索匹配! if(classes) &#123; // For every CSS class the element has... for(var x = 0; x &lt; classes.length; x++) &#123; // If it has the CSS class we want... if(classes[x] == &quot;classA&quot;) &#123; // Bingo! console.log(&quot;Anchor element clicked!&quot;); // Now do something here.... &#125; &#125; &#125; &#125;&#125;); 通过上面的介绍，大家应该能够体会到使用事件委托对于web应用程序带来的几个优点： 1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。 2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。 3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。 写到这里，突然想起了之前对于Dojo DataGrid的困惑：那么多的rows和cells，如何处理他们事件之间的关系。现在想想，使用委托就很简单了。所有的事件委托到grid最外层的节点上，当事件发生的时候通过一些方法来获取和添加事件的额外属性，如rowIndex, cellIndex，之后在分配到onRowClick,onCellClick之类的处理函数上。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>事件代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中set Timeout和set Interval之间的爱恨情仇]]></title>
    <url>%2F2017%2F08%2F12%2Fjavascript%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[javascript定时器是一个比较喜欢欺骗别人的东西，不按套路出牌在之前的认知当中，我们都是认为javascript的定时器是当运行到该定时器的执行代码的时候，该定时器的代码就会执行；但是你会发现； 12345div.onclick = function()&#123; setTimeout(function() &#123; document.getElementById(&apos;inputField&apos;).focus(); &#125;, 0); &#125;; 突然出现了一个间隔时间为0，很蒙圈，那还需要定时器有什么用呢； 123456789101112131415setTimeout(function() &#123; while (true) &#123; &#125; &#125;, 100); setTimeout(function() &#123; alert(&apos;你好!&apos;); &#125;, 200); setInterval(callbackFunction, 200); 在这里，你发现第一个定时器中的循环让代码出现要给死循环；之后应该运行alert和callbackFn，但是事实上这两个都没有如期出现；javascript定时器很让人着迷啊； 事实在于:javascript中，程序都是单线程运行的，浏览器不管在什么时候始终都只有一个线程在运行javascript程序；javascript是单线程运用； 那么浏览器又是如何处理单线程问题的呢？ 在浏览器中允许多个线程异步执行，这些线程在内核的控制下相互配合有保持同步；对于浏览器中的js引擎来说，它是基于事件驱动的，从代码的角度来说，各种任务都是回掉函数，javascript引擎一直在等待着事件任务队列中任务的到来；由于javascript是单线程运行的，所有处在队列中的事件需要排队等候；一个一个被浏览器所执行； js定时触发的线程： 注意这里的浏览器模型定时计数器并不是由JavaScript引擎计数的,因为JavaScript引擎是单线程的,如果处于阻塞线程状态就计不了时,它必须依赖外部来计时并触发定时,所以队列中的定时事件也是异步事件. 由图可知,在这t1的时间段内,继鼠标点击事件触发后,先前已设置的setTimeout定时也到达了,此刻对JavaScript引擎来说,定时触发线程产生了一个异步定时事件并放到任务队列中, 该事件被排到点击事件回调之后,等待处理. 同理, 还是在t1时间段内,接下来某个setInterval定时器也被添加了,由于是间隔定时,在t1段内连续被触发了两次,这两个事件被排到队尾等待处理. 可见,假如时间段t1非常长,远大于setInterval的定时间隔,那么定时触发线程就会源源不断的产生异步定时事件并放到任务队列尾而不管它们是否已被处理,但一旦t1和最先的定时事件前面的任务已处理完,这些排列中的定时事件就依次不间断的被执行,这是因为,对于JavaScript引擎来说,在处理队列中的各任务处理方式都是一样的,只是处理的次序不同而已. t1过后,也就是说当前处理的任务已返回,JavaScript引擎会检查任务队列,发现当前队列非空,就取出t2下面对应的任务执行,其它时间依此类推,由此看来: javascript的单线程：如果队列非空,引擎就从队列头取出一个任务,直到该任务处理完,即返回后引擎接着运行下一个任务,在任务没返回前队列中的其它任务是没法被执行的.单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果你在javascript代码中插入一个setTimeout，并且设置时间为0；只是代表这个任务会被立刻插入到队列中，但不是立即执行；所以javascript中的定时器可能会出现不按预想中的那样执行的效果；一般来说定时器是最后执行的代码；定时器最重要的是： 指定的时间间隔表示何时将定时器的代码添加到队列中，而不是何时执行代码； 当使用setInterval时，仅当没有定时器的任何其它代码时，才将定时器代码添加到队列中，这样会确保定时器代码加入到队列的时间的间隔是为指定的间隔，请注意这只是加入队列的时间间隔，并不是执行代码的时间间隔，所以使用setInterval还是会存在两个问题： （1）某些间隔会被跳过了 （2）多个定时器的代码执行间隔可能会比预期的要小。 注意：最好不要使用setInterval，尽量使用setTimeout的延时递归来代替setInterval 因为使用setInterval来进行回掉容易产生回掉堆积，特别是时间非常短的时候； 123456789101112131415function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3000);setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3000);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中闭包的理解]]></title>
    <url>%2F2017%2F08%2F12%2F%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[闭包：指有权访问另一个函数作用域中的变量的函数。 闭包是指这样的作用域，它包含有一个函数，这个函数可以调用被这个作用域所封闭的变量、函数或者闭包等内容。通常我们通过闭包所对应的函数来获得对闭包的访问。 函数作用域123456789101112function init() &#123; let name = &quot;Mozilla&quot;; // name 是一个被init创建的局部变量 function displayName() &#123; // displayName() 是一个内部函数, alert(name); // 一个闭包使用在父函数中声明的变量 //注意，不要误认为闭包一定是被返回的函数，只要可以调用另外一个函数作用域的变量的函数就叫做闭包。 &#125; displayName();&#125;init(); 函数 init() 创建了一个局部变量 name和一个名为 displayName() 的函数。 displayName() 是一个内部函数——定义于 init() 之内且仅在该函数体内可用。displayName() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数 init() 中声明的 name 变量。 闭包12345678910function makeFunc() &#123; var name = &quot;Mozilla&quot;; function displayName() &#123; alert(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); 运行这段代码的效果和之前的 init() 示例完全一样：字符串 “Mozilla” 将被显示在一个 JavaScript 警告框中。其中的不同 — 也是有意思的地方 — 在于 displayName() 内部函数在执行前被从其外围函数中返回了。 这段代码看起来别扭却能正常运行。在一些编程语言中，函数中的局部变量仅在函数的执行期间可用。一旦 makeFunc() 执行过后，我们会很合理的认为 name 变量将不再可用。然而，因为代码运行的没问题，所以很显然在 JavaScript 中并不是这样的。 这个谜题的答案是 myFunc 变成一个 闭包 了。 闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 “Mozilla” 字符串形成。 闭包的用处1，闭包可以访问当前函数以外的变量 123456789function getOuter()&#123; var date = &apos;815&apos;; function getDate(str)&#123; console.log(str + date); //访问外部的date &#125; return getDate(&apos;今天是：&apos;); //&quot;今天是：815&quot;&#125;getOuter();getDate是一个闭包，该函数执行时，会形成一个作用域A，A中并没有定义变量date，但它能在父一级作用域中找到该变量的定义。 2、即使外部函数已经返回，闭包仍能访问外部函数定义的变量 12345678910function getOuter()&#123; var date = &apos;815&apos;; function getDate(str)&#123; console.log(str + date); //访问外部的date &#125; return getDate; //外部函数返回&#125;var today = getOuter();today(&apos;今天是：&apos;); //&quot;今天是：815&quot;today(&apos;明天不是：&apos;); //&quot;明天不是：815&quot; 3、闭包可以更新外部变量的值（模拟私有方法） 1234567891011function updateCount()&#123; var count = 0; function getCount(val)&#123; count = val; console.log(count); &#125; return getCount; //外部函数返回&#125;var count = updateCount();count(815); //815count(816); //816]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setTimeout和setInterval之间的爱恨情仇]]></title>
    <url>%2F2017%2F08%2F12%2FJS%20%E4%B8%ADsetTimeout%E5%92%8Cset%20Interval%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[在说起javascript中定时器的问题，需要事先明确这样几个概念： 1，setTimeout：setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式,2，setInterval: setInterval()则是在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除；3，clearInterval: setInterval定时器在执行之后会返回一个对应的定时器ID，可以通过clearInterval（ID）删除定时器的执行4，clearTimeout： set Timeout定时器在执行之后也会返回一个对应的定时器ID，通过clearTimeout就可以删除对应的定时器执行 JS中的事件循环机制机制：浏览器（或者说JS引擎）执行JS的机制是基于事件循环。由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 在JS中，这个任务队列是一个包含各种消息的消息队列，这些消息就是注册异步事件的时候添加的回掉函数； 然而JS主线程只负责一件事情，那就是从消息队列中取消息，执行消息，在取消息，执行消息；当消息队列为空的时候，就会等待消息队列为非空的时候取消息，而且主线程只有在当前的消息执行完毕之后才会去取下一个消息执行；这种机制就叫做事件循环机制， 三、JS定时器的工作原理（扣别人的） 在解释上面问题的答案之前我们先来了解一下定时器的工作原理，这里将用引用How JavaScript Timers Work中的例子来解释定时器的工作原理，该图为一个简单版的原理图。 上图中，左侧数字代表时间，单位毫秒；左侧文字代表某一个操作完成后，浏览器去询问当前队列中存在哪些正在等待执行的操作；蓝色方块表示正在执行的代码块；右侧文字代表在代码运行过程中，出现哪些异步事件。该图大致流程如下： 程序开始时，有一个JS代码块开始执行，执行时长约为18ms，在执行过程中有3个异步事件触发，其中包括一个setTimeout、鼠标点击事件、setInterval第一个setTimeout先运行，延迟时间为10ms，稍后鼠标事件出现，浏览器在事件队列中插入点击的回调函数，稍后setInterval运行，10ms到达之后，setTimeout向事件队列中插入setTimeout的回调当第一个代码块执行完成后，浏览器查看队列中有哪些事件在等待，他取出排在队列最前面的代码来执行在浏览器处理鼠标点击回调时，setInterval再次检查到到达延迟时间，他将再次向事件队列中插入一个interval的回调，以后每隔指定的延迟时间之后都会向队列中插入一个回调后面浏览器将在执行完当前队头的代码之后，将再次取出目前队头的事件来执行这里只是对定时器的原理做一个简单版的描述，实际的处理过程比这个复杂。 定时器的用法：setTimeOut用法setTimeout函数的用法如下： 123456789var timeoutID = window.setTimeout(func, [delay, param1, param2, ...]); var timeoutID = window.setTimeout(code, [delay]); timeoutID：定时器ID号，它可以在clearTimeout()函数中被用来清除定时器。func：被执行的函数。code：（替代的语法）一个被执行的代码串。delay：延迟的时间，单位毫秒。如果没有指定，默认为0。 我们可以使用window.setTimeout或setTimeout，两个写法基本一样，只不过window.setTimeout将setTimeout函数作为全局window对象的一个属性来引用。 应用示例： 12345function timeout()&#123; document.getElementById(&apos;res&apos;).innerHTML=Math.floor(Math.random()*100 + 1); &#125; setTimeout(&quot;timeout()&quot;,5000); 代码执行时，5秒后调用timeout()函数 setInterval用法setInterval函数的参数及用法和setTimeout函数一样，请参照上文的setTimeout函数的用法介绍。不同的是，setInterval每隔一定的时间执行当中的func或code代码。 应用示例： 12345678910var tt = 10; function timego()&#123; tt--; document.getElementById(&quot;tt&quot;).innerHTML = tt; if(tt==0)&#123; window.location.href=&apos;/&apos;; return false; &#125; &#125; var timer = window.setInterval(&quot;timego()&quot;,1000); 函数timego()定义了页面元素#tt显示的内容，当tt等于0时，页面定向到首页。然后我们定义一个定时器timer，使用setInterval()每隔1秒调用一次timego()。这样timego会执行10次，每次数字tt会减1，直到为0。那么如果想停止定时器，可以使用以下代码： window.clearInterval(timer); setTimeout和setnterval之间的区别：1，setTimeout在时间间隔之后将定时器插入到事件循环队列之中，若前面有执行时间较长的程序，可能会延迟执行；2，set Interval按照时间间隔将定时器插入到循环队列之中，但是循环队列中某一时刻只能有一个定时器对象实例；因此在set Interval中存在以下两个问题： （1）某些间隔会被跳过；（2）多个定时器的代码执行之间的间隔可能比预期的小；3， setTimeout和setInterval的作用只是把你要执行的代码在你设定的一个时间点插入到引擎维护的一个消息队列中, 插入消息队列并不意味着你的代码就会立马执行的,理解这一点很重要 对于set Timeout： 1234567 function click() &#123; // code block1... setTimeout(function() &#123; // process ... &#125;, 200); // code block2 &#125; 假设我们给一个button的onclick事件绑定了此方法, 当我们按下按钮后, 肯定先执行block1的内容, 然后运行到setTimeout的地方, setTimeout会告诉浏览器说, “200ms后我会插一段要执行的代码给你的队列中“, 浏览器当然答应了(注意插入代码并不意味着立马执行), setTimeout代码运行后, 紧跟其后的block2代码开始执行, 这里就开始说明问题了, 如果block2的代码执行时间超过200ms, 那结果会是如何? 或许按照你之前的理解, 会理所当然的认为200ms一到, 你的process代码会立马执行…事实是, 在block2执行过程中(执行了200ms后)process代码被插入代码队列, 但一直要等click方法执行结束, 才会执行process代码段, 从代码队列上看process代码是在click后面的, 再加上js以单线程方式执行, 所以应该不难理解. 如果是另一种情况, block2代码执行的时间&lt;200ms, setTimeout在200ms后将process代码插入到代码队列, 而那时执行线程可能已经处于空闲状态了(idle), 那结果就是200ms后, process代码插入队列就立马执行了, 就让你感觉200ms后, 就执行了. 再看看setInterval ：它存在两个问题 （1）某些间隔会被跳过； （2）多个定时器的代码执行之间的间隔可能比预期的小；1234567function click() &#123; // code block1... setInterval(function() &#123; // process ... &#125;, 200); // code block2 &#125; 和上面一样我们假设通过一个click, 触发了setInterval以实现每隔一个时间段执行process代码这里写图片描述 比如onclick要300ms执行完, block1代码执行完, 在5ms时执行setInterval, 以此为一个时间点, 在205ms时插入process代码, click代码顺利结束, process代码开始执行(相当于图中的timer code), 然而process代码也执行了一个比较长的时间, 超过了接下来一个插入时间点405ms, 这样代码队列后又插入了一份process代码, process继续执行着, 而且超过了605ms这个插入时间点, 下面问题来, 可能你还会认为代码队列后面又会继续插入一份process代码…真实的情况是,由于代码队列中已经有了一份未执行的process代码, 所以605ms这个插入时间点将会被“无情”的跳过, 因为js引擎只允许有一份未执行的process代码, 这里我想我们都明白了JS引擎的小九九了吧… 4，内存泄漏问题：内联书写setInterval时，由于匿名函数被定义于全局中，不能够计时器的清除，因此很容易造成内存泄露。 规避办法： 12345setTimeout(function()&#123; // 其他代码 setTimeout(arguments.callee, interval); &#125;, interval); // 备注:interval指的是毫秒数。 // 基本原理是：链式的调用setTimeout，每次函数执行时会创建一个新的定时器，第二个setTimeout调用使用了arguments.callee来获取对当前执行的函数的引用，并为它设置另一个定时器。这样做的好处是，在前一个定时器代码执行完毕之后，不会在队列中加入新的定时器代码，同时还能够没有任何缺失的间隔，从而避免连续运行。callee 属性是 arguments 对象的一个成员，他表示对函数对象本身的引用，这有利于匿名函数的递归或确保函数的封装性]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中内存泄漏的问题]]></title>
    <url>%2F2017%2F08%2F12%2Fjavascript%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[内存泄漏是一个常见的性能问题，常常会导致程序的崩溃，运行缓慢，高延迟或者其他的一下问题； 内存泄漏：内存泄漏是指分配给应用的内存不能被重新分配，即使在内存已经不被使用的时候。正常情况下，垃圾回收器在DOM元素和event处理器不被引用或访问的时候回收它们。但是，IE的早些版本(IE7和之前)中内存泄漏是很容易出现的，因为内存管理器不能正确理解Javascript生命周期而且在周期被打破(可以通过赋值为null实现)前不会回收内存。 Javascript 中的垃圾收集机制：javascript具有自动垃圾收集机制，也就是说，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理；垃圾收集器会按照固定的时间间隔，周期性的执行这一操作； javascript中有两种垃圾回收方法：标记清除，引用计数； javascript中内存泄漏的几种方式1，意外的全局变量JavaScript 宽容性的一点表现在它处理未声明变量的方式上：一个未声明变量的引用会在全局对象中创建一个新的变量。在浏览器的环境下，全局对象就是 window 123 function leaks()&#123; leak = &apos;xxxxxx&apos;;//leak 成为一个全局变量，不会被回收&#125; 另一种意外全局变量被创建的方式是通过this： 12345function foo() &#123; this.str= &quot;this is a global&quot;;&#125;//在这里str也是一个全局变量，只不过比较隐晦罢了foo(); 为了阻止这种错误发生，在你的Javascript文件最前面添加’use strict;’。这开启了解析JavaScript的阻止意外全局的更严格的模式。 2，闭包引起的内存泄漏闭包可以导致内存泄漏是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了内部方法还可以继续访问在外部方法中定义的私有变量。对Javascript程序员来说最好的做法是在页面重载前断开所有的事件处理器。var getBIBAO= (function(){ var leak = ‘1234567’;// 被闭包所引用，不会被回收 return function(){ console.log(leak); }})()1234567 3，循环引用简单来说假如a引用了b,b又引用了a,a和b就构成了循环a和b循环引用：12345678910111213var a=new Object;var b=new Object;a.r=b;b.r=a;a循环引用自己：var a=new Object;a.r=a; 用很常见且大部分情况下是无害的，但当参与循环引用的对象中有DOM对象或者ActiveX对象时，循环引用将导致内存泄露。我们把例子中的任何一个new Object替换成document.getElementById或者document.createElement就会发生内存泄露了。 4,dom清空或删除时，事件未清除导致的内存泄漏 1234567891011121314151617&lt;div id=&quot;container&quot;&gt; &lt;/div&gt;$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123; console.log(&apos;click&apos;);&#125;).remove();// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题12345678&lt;div id=&quot;container&quot;&gt; &lt;/div&gt;$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123; console.log(&apos;click&apos;);&#125;).off(&apos;click&apos;).remove();//把事件清除了，即可从内存中移除1234567 5，被遗忘的定时器或者回掉在javascript中，使用set Interval之后，不把这个清除掉容易产生内存泄漏的问题； 12345678var someResource = getData();setInterval(function() &#123; var node = document.getElementById(&apos;Node&apos;); if(node) &#123; // Do stuff with node and someResource. node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); 这个例子表明了跳动的计时器可能发生什么：计时器使得节点或数据的引用不再被需要了。代表node的对象将来可能被移除，使得整个块在间隔中的处理不必要。然而，处理函数，由于间隔仍然是活跃的，不能被回收（间隔需要被停掉才能回收）。如果间隔处理不能被回收，它的依赖也不能被回收。那意味着可能存储着大量数据的someResource，也不能被回收。 6，由于子元素的存在引起的内存泄漏问题 黄色是指直接被 js变量所引用，在内存里 红色是指间接被 js变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的 子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript作用域链和执行环境的理解]]></title>
    <url>%2F2017%2F08%2F09%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[个人理解：执行环境的概念：每个函数在调用的时候会创建一个自己的执行环境。当执行流进入一个函数的时候，函数的环境就会被推入一个环境栈，而在函数执行之后，栈将其执行环境弹出，并将控制权移交给之前的执行环境。执行环境定义了变量和函数有权访问的其他数据，并定义了他们各自的行为； 变量对象：当函数被调用的时候，每个执行环境都会有一个与之相关的变量对象，环境中定义的所有变量和对象都保存在这个对象。 变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 它是一个抽象的概念，不同的上下文中，它表示使用不同的object。例如，在global全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。 作用域链：在一个函数被创建的时候，会创建一个预先包含全局变量对象的作用域链，并把这个作用域链保存于内部的【Scope】属性中；所以说创建任何一个函数的时候就会创建包含全局变量对象的作用域链；当函数第一次被调用的时候，会创建一个执行环境以及相应的作用域链，然后通过复制函数的【scope】属性中的对象构建起执行环境的作用域链，然后又有一个活动对象（这里作为变量对象）被创建并被推入执行环境作用域链的前端，最后使用this，arguments，和其他命名参数来初始化函数活动对象（如果是函数，则将其活动对象作为变量对象）； 性质：1，作用域链的前端始终都是当前执行代码所在环境的变量对象 2，全局执行环境的的变量对象之中都是作用域链的最后一个变量对象； 3，作用域链的作用在于保证对执行环境中有权访问的所有变量和函数的顺序访问； 4，内部环境变量可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境的任何变量和函数； 5，作用域链本质是一个指向变量对象的指针列表，他只引用但不实际包含变量对象。 度娘精选：执行上下文栈：注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。 一系列活动的执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。 当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。 执行上下文：也称为执行环节，一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。主要有三个属性：变量对象(variable object)，this指针(this value)，作用域链(scope chain)。 活动对象当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。 即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象arguments 。 作用域链优化： 从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树三种遍历的非递归思路（JAVASCRIPT)]]></title>
    <url>%2F2017%2F07%2F27%2Fbinary_tree_traversal%2F</url>
    <content type="text"><![CDATA[二叉树在图论中是这样定义的：二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。然而，没有足够的信息来区分左结点和右结点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。 这里，我使用javascript来写二叉树遍历的三种非递归方式，因为楼主学的是javascript，对于C，JAVA，C++这个都不是很熟，所以就只好使用javascript代替； 前序遍历第一种方法 12345678910111213141516171819202122232425var preorderTraversal = function(root) &#123; var stack = []; var res = []; var p = root; if(root == null)return []; while(stack.length!=0 || p!=null)&#123;//Side by side to join the array, and deposited in the stack, the future need to use these root nodes into the right sub-tree while(p!=null)&#123; stack.push(p); res.push(p.val); p = p.left; &#125; // When p is empty, it means that both the root and the left subtree are traversed, and the right tree goes if(stack.length!=0)&#123; p = stack.pop(); p = p.right; &#125; &#125; return res;&#125;; 第二种方法 12345678910111213141516var preorderTraversal = function(root) &#123; var result = []; var stack = []; var p = root; while(stack.length!=0 || p != null) &#123; if(p != null) &#123; stack.push(p); result.push(p.val); // Add before going to children p = p.left; &#125; else &#123; var node = stack.pop(); p = node.right; &#125; &#125; return result;&#125;; 中序遍历第一种方法 12345678910111213141516171819202122var inorderTraversal = function(root) &#123; var stack = []; var res = []; var p = root; if(root == null) return []; while( stack.length!=0 || p!=null)&#123; while(p!=null)&#123; stack.push(p); p = p.left; &#125; if(stack.length!=0)&#123; p= stack.pop(); res.push(p.val); p = p.right; &#125; &#125; return res;&#125;; 第二种方法12345678910111213141516var inorderTraversal = function(root) &#123; var result = []; var stack = []; var p = root; while(stack.length!=0 || p != null) &#123; if(p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; var node = stack.pop(); result.push(node.val); // Add after all left children p = node.right; &#125; &#125; return result;&#125;; 后序遍历第一种方法 123456789101112131415161718192021222324var postorderTraversal = function(root) &#123; var Stack = []; var result = []; if(root==null) return []; Stack.push(root); while(Stack.length!=0) &#123; var node= Stack.pop(); result.push(node.val); if(node.left) Stack.push(node.left); if(node.right) Stack.push(node.right); &#125; return result.reverse(); &#125;; 第二种方法 1234567891011121314151617var postorderTraversal = function(root) &#123; var result = []; var stack = []; var p = root; while(stack.length!=0 || p != null) &#123; if(p != null) &#123; stack.push(p); result.unshift(p.val); // Reverse the process of preorder p = p.right; // Reverse the process of preorder &#125; else &#123; var node = stack.pop(); p = node.left; // Reverse the process of preorder &#125; &#125; return result;&#125;;]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉链表的建立和三种遍历的递归方式]]></title>
    <url>%2F2017%2F07%2F25%2Fbinary_tree%2F</url>
    <content type="text"><![CDATA[二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。 一棵深度为k，且有2^k-1个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。 二叉树的建立过程是二叉链表的方式，即当前结点不光存储当前结点的数据，还存储左右孩子的指针 这里多加了一个level用来判断结点在第几层 二叉树中的中序和后序遍历都是因为结点的建立问题，不能用于建立一个二叉树12345678910include&lt;stdlib.h&gt;include&lt;stdio.h&gt;typedef char ElemType;//二叉链表的构建形式typedef struct binaryTree&#123; ElemType data; struct binaryTree *lchild,*rchild;&#125;binaryTree,*BiTree; 12345//访问一个结点并打印void visited(char c,int level)&#123; printf(&quot;%c在第%d层 \n&quot;,c, level);&#125; 1234567891011121314151617//使用前序的方式建立一个二叉树void PreorderCreateBinaryTree(BiTree *T)&#123; char c; scanf(&quot;%c&quot;,&amp;c); if( &apos;#&apos; == c) &#123; *T = NULL; &#125; else&#123; *T = (BiTree)malloc(sizeof(binaryTree)); (*T)-&gt;data = c; PreorderCreateBinaryTree(&amp;(*T)-&gt;lchild); PreorderCreateBinaryTree(&amp;(*T)-&gt;rchild); &#125;&#125; 12345678910//前序遍历二叉树void PreorderTraversal(BiTree T,int level)&#123; if( T ) &#123; visited(T-&gt;data,level); PreorderTraversal(T-&gt;lchild,level + 1); PreorderTraversal(T-&gt;rchild, level + 1); &#125;&#125; 12345678910//中序遍历二叉树void OrderTraversal(BiTree T ,int level)&#123; if( T ) &#123; PreorderTraversal(T-&gt;lchild,level + 1); visited(T-&gt;data,level); PreorderTraversal(T-&gt;rchild,level + 1); &#125;&#125; 12345678910//后序遍历二叉树void PosteriorTraversal(BiTree T,int level)&#123; if( T ) &#123; PosteriorTraversal(T-&gt;lchild,level + 1); PosteriorTraversal(T-&gt;rchild,level + 1); visited(T-&gt;data,level); &#125;&#125; 123456789101112131415161718192021222324252627282930//层序的方式实现二叉树的遍历--------------------------------------------//利用递归的方法，按层进行打印，我们把根节点当做第0层，之后层次依次增加，如果我们想打印第二层怎么办呢，利用递归的代码如下：int sequence_traversal_level(BiTree T, int level) &#123; if (!T || level &lt; 0) //当树的结点不存在，并且或者根节点不存在（深度小于0）的时候，结束 return 0; if (0 == level) &#123; //当level为0的时候，说明这一层遍历完成，需要换行 printf(&quot;%c &quot;,T-&gt;data); return 1; &#125; return sequence_traversal_level(T-&gt;lchild, level - 1) + sequence_traversal_level(T-&gt;rchild, level - 1);//左右孩子的返回值加一次为0，才能确定没有下一层，否则就需要遍历下一层；&#125;//如果我们成功的打印了给定的层次，那么就返回非0的正值，如果失败返回0。//有了这个思路，我们就可以应用一个循环，来打印这颗树的所有层的节点，但是有个问题就是我们不知道这棵二叉树的深度，//怎么来控制循环使其结束呢，仔细看一下sequence_traversal_level，如果指定的Tree是空的，那么就直接返回0，//当返回0的时候，我们就结束循环，说明没有节点可以打印了。void sequence_traversal(BiTree T) &#123; int i = 0; for (i = 0; ; i++) &#123; if (!sequence_traversal_level(T, i)) //当链表中的第i层不存在的时候退出，或者树为空的时候 遍历完成，退出循环 &#123; break; &#125; else&#123; //否则就是该层次打印完成，换行 printf(&quot;\n&quot;); &#125; &#125; printf(&quot;\n&quot;);&#125; 12345678910int main()&#123; BiTree T; int level = 1; printf(&quot;建立二叉树并访问节点&quot;); printf(&quot;请输入结点数据，建立树:\n&quot;); PreorderCreateBinaryTree(&amp;T); PosteriorTraversal(T , level); return 0;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用命令行查看使用npm全局安装的包]]></title>
    <url>%2F2017%2F07%2F07%2Fnpm%E5%8C%85%2F</url>
    <content type="text"><![CDATA[在使用node的使用，用npm安装了很多包，一个项目一个项目的接，所以对于手机全局安装的包就不是很清楚，从google上找到一个快捷命令，直接就可以列出来全局安装的包 npm list -g --depth 0 命令行截图： -g:全局的安装包list：已安装的node包–depth 0：这个参数我不是很清楚，应该是根目录的意思把]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络中OSI七层模型各层的功能]]></title>
    <url>%2F2017%2F07%2F05%2Fosi%2F</url>
    <content type="text"><![CDATA[物理层物理层的主要功能是：利用传输媒质为数据链里层提供物理连接，实现比特流的透明传输 数据链路层数据链路层的主要功能是：通过各种控制协议，将有差错的物理信道变成无差错，能可靠传输数据帧的数据链路； 网络层网络层的主要功能是：通过路由选择算法，威豹纹或分组通过子网选择最合适的路径。该层控制数据链路层与传输层之间的信息转发，建立，维持和中指网络的连接； 传输层传输层的功能是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，传输层的的作用是向高层屏蔽下层数据通信的细节，即向用户透明的传递报文； 会话层会话层的功能：向两个实体的表示层提供建立和使用连接的方法，组织和协调两个会话进程之间的通信，并对数据交换进行管理； 表示层表示层的功能：对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传递给会话层； 应用层应用层的功能：直接向用户提供服务，完成用户希望在网络上完成的各种工作；]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用hexo，github和注册域名搭建个人博客系统]]></title>
    <url>%2F2017%2F07%2F03%2Fhexo-domain%2F</url>
    <content type="text"><![CDATA[在程序员的世界里，越来越多的人重视开源和博客的构建，如果在找工作中你能在github上有一个issue或者有几个开源项目被别人采纳，或者你有一个属于自己的博客系统，博文被更多人所赞同，那么这在你的求职过程中将会有莫大的帮助；作为一名程序猿，在学习的过程中渐渐感觉到知识体系越来越丰富，那么把这些零碎的知识写成博客放在服务器端不失为一种很明智的选择，LZ自己根据hexo博客系统自己搭了一个博客，在这里跟大家分享；欢迎点评，指点，本人将万分感激； 一，hexo必要配置：window下 node必须要安装： 用来生成静态页面，可以在nodejs官网下载最新版本的，根据步骤一路安装即可 git必须安装： git的作用是用来把静态的博客提交到github 下载地址：https://www.sourcetreeapp.com/，该版本是中文的github必须安装：用来做远端的服务器，域名来用，网上很多这中文章，自己注册一个根据步骤来就好 1234567hexo在本地全局下载安装：简单的配置hexo如下所示 1，npm install hexo-cli -g:在命令行终端运行该命令就会在全局下载安装hexo的脚手架 2， hexo init：建立一个专门用来存放hexo博客文的文件夹，然后在文件夹根目录下运行hexo init或者hexo init blog这样就会创建一个博客文件夹，在这里里面可以配置你的博客，存放博客文（可以用csdn的markdown来制作博客文，这个还可以下载到本地，md文件后缀） 3，从csdn博客那里下载一个制作好的博客文章，放到blog\source\_posts目录下，_posts文件夹专门用于存放你的文章 4，运行hexo server 在命令行运行该命令可以在本地浏览器查看hexo博客文章的样式，方便简洁，直接在本地浏览器输入http://localhost:4000就可以在浏览器查看你的博客文章； 下面是我建立博客的根目录 但是到这里你才刚把hexo搭建好，还不能在服务器上访问，我这里暂时使用的是github提供的github pages，这是github提供的静态页面托管服务器，只要注册了github账号就可以使用；具体可参考github pages 二，下面说一下如何来配置github；1，在你的github账号上面新建一个Repository，这个Repository的名字必须为your_user_name.github.io;这是一个固定的写法，这样就建立了你自己的一个github仓库，你可以使用这个作为你的服务器来托管你的静态博客页面； 2，建立github和本地blog根目录的一个关联 12345配置你的_config.yml文件（根目录下），注意hexo中：后面跟内容必须加空格 deploy: type: git repository: https://github.com/your_user_name/your_user_name.github.io.git branch: master 1然后执行npm install hexo-deployer-git --save执行这个命令之后你才可以使用git把你的文章部署到github上 1最后执行一下hexo deploy就可以把你制作好的文章部署到github上去 三，将自己的域名和github解析经过上面两个步骤虽然已经建立好自己的博客，而且你可以对自己的博客进行修改，添加等，但是始终用的是别人的服务器，总有点受制于人的感觉；所以我又自己注册了一个域名，并把域名映射到github的服务器，这样直接使用我注册的域名就可以访问我的博文，拜托了github的魔杖； 首先你要有一个域名对吧，在国内比较好的域名注册网站就是阿里云，腾讯云，百度元，楼主注册了一个阿里云的账号；国外也可以注册免费域名，网站地址为http://www.freenom.com/zh/index.html?lang=zh,注册流程可以问度娘，这里不再叙述 注册过域名之后，进入阿里云的控制台 之后点击最右侧对的解析，将你的域名解析成github的 下面这个从网上查找的办法不可行，无法正常解析在这里记录类型选择CNAME，用来将域名指向一个域名，实现与被指向域名相同的访问效果；主机类型选择：*，用来指定所有的子域名都将指向同一地址。最后记录值就是你需要指定域名指向的地址，没有http,也没有www;然后保存等待域名解析完成之后就可以访问个人域名来达到访问github指定域名的效果； 可行的域名解析办法 在阿里云管理控制台中,选择【域名】》【域名列表】》【全部域名】中刚刚购买的域名,点击解析按钮这时会提醒你选择解析到阿里云主机,或者其他主机,这时需要将你在Github上创建的Github Pages的域名 xxx.github.io进行查询,得到一个IP地址。 151.101.72.133是我的github的地址（就是xiangzhihong.github.io地址，你也可以ping自己的xx.github.io，个人建议使用ping,方便快捷，不用费事从github查）. 按照这个方式解析就可以了；一般解析完成也就十分钟左右，太长了就说明你的解析不正确； Github解析在Github的xxx.github.io项目,进入【Settings】标签页,在【Custom domain】功能中,将刚刚申请的域名写进去。 如果你填写正确。就会出现上方哪个：Your site is published at …… 这样填写完成之后呢，看样子万事大吉了，解析完成之后，你使用xxx.github.io或者你的个人域名xxx.com都可以实现访问你的域名； 但是新的问题出现了，当你在客户端写了一个博客之后，在重新部署到github上，你发现使用两种方式都不能打开你的博客了~这是多么让人难受的一件事情； 那么，解决办法如下： 在你的电脑上，找到你的blog根目录 在你的source文件夹中。加入一个文件夹，CNAME， 文件夹内写的就是你需要解析的域名，不需要加http:// 也不需要加www。 之后再把你的hexo博客部署到服务器上，记得一定要部署，不然还是没有办法达到修改的目的； 请注意，注册域名之后一定要实名认证，认证需要等三到五天，记住一定要实名认证，否则你的解析结果将一直 最后就完成了实现域名到服务器的映射，你就可以使用自己的域名来实现自己的博客，感觉很神奇把。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费打造个人网站，免费域名，免费空间，ftp使用，数据库等，免费就能搭建个人网站]]></title>
    <url>%2F2017%2F07%2F02%2Fdomain-name-server%2F</url>
    <content type="text"><![CDATA[作为一名编程爱好者，有自己的一个域名空间是逼格多高的一件事啊，使用自己的云空间可以做很多事情，不管你是前端，后端，测试，软件工程师，有一个存储自己内容的独立空间，并且由你自己支配，使用；想想逼格就很高；下面介绍LZ在拼杀了两天的时间才测试出来的一套完整建立自己网站的流程，亲测有效！ 个人成果展示 通过个人域名，访问服务器图片： 通过个人域名，访问个人写的简易网页： 第一，使用freenom注册免费个人域名并解析到个人空间想要建站必须要有自己的域名吧，所以说首先需要建立一个属于自己独特的域名很重要，国内比较好的可以用腾讯云或者百度云，这里我们使用国外的一个免费提供域名的网站http://www.freenom.com/zh/index.html?lang=zh,从上面的图中可以看到我的域名就是一个以tk结尾的顶级域名，使用freenom可以注册比如.tk,.ml.ga,.cf的顶级域名，进入freenom官网如下图：（这里我已经把官网翻译为中文，LZ看不懂英文） 之后你就可以输入你想要注册的域名，查询一下你的域名是否可以注册，一般来说，普通的域名都是可以注册的； 点击你想要注册域名后缀的哪个，现在获取，一般freenom提供的是1到1年的都有，在这一年之内可以免费使用，到距离一年还有一个月的时候会邮箱提醒你域名续费，这个续费也是不要钱的；可以免费续费，就是说你可以一直用着这个域名了；获取之后，域名会被添加到你的购物车中，在购物车中你可以选择使用这个域名多久，一年之内都是免费的，记住，你可能需要注册一个freenom账号才能使用，不过你也可以使用google账号登录，这里我是用的就是google的账号，很方便，之后使用的hostinger登录也是使用的google账号，能在很多外国网站进行登录注册； 那么现在你就有了自己的一个域名了，距离人生巅峰已经不远了 在freenom主页的service中找到My Domains点进入就是管理你的域名了， 点击右边的Manage Domain来管理解析你的域名； 如果你仅仅想让域名指向一个地址，那就选择URL Forwarding,不过这里我们要指向自己的域名服务器，选择Nameservers,打开后输入如下信息： 域名服务器最少两个，最多五个，根据后面的直接粘贴复制就好，后面我会告诉大家在哪里找到。输入完成后，点击Change Nameservers保存即可。 第二，获取免费个人空间网上其实也有很多网站都能提供给你空间，甚至直接给你一个空间免费使用，但是局限性都非常大。而我们想要的个人空间，带有FTP，MYSQL吧，所以这里我们使用https://www.hostinger.com.hk/web-hosting 因为这个网站的服务器在香港，所以跑起来加载速度会比较慢，你完全可以使用上面注册的google账号注册并且登陆： 首页就有免费云空间的介绍 点击订购云空间就可以获取自己的空间了，这里我们所使用的是第一个免费的云空间，对于个人网站来说完全够用了，因为我的已经解析过主机了，所以就没有办法截图了，当你第一次订购云主机的时候会提醒你新建云主机，这里你就能把之前注册的域名填进去，这里不需要http：// ，也不需要www，一路根据网站的操作就好,订购云主机完成之后，每次点击客户中心就可以进入到你的个人空间管理页面；如下： 在这个个人主机的控制首页里面，你可以操作你的空间的内容操作在这里都可以找到，空间的信息，数据库，和ftp都可以在这个主页中去寻找操作； 解析域名 点击账号-》信息 在获取免费域名的最后一步，有一个操作是把免费域名的DNS服务器只想你的云主机，那么在这里就会出现你应该解析的DNS地址： 从个人云主机信息的NS服务器信息可以可以看到四个DNS服务器地址，将这四个拷贝到你之前freenom注册域名的nameservers下的DNS服务器哪里就好了，这样就完成了域名和云空间的解析；也就是说你可以使用域名来访问你的云空间了： 费了一早上的时间才出现这个页面，突然觉得人生还是很美好的； FTP和MySQL下面回到管理界面，向下拉可以看到FTP和MySQL的管理选项： 可以看到在MySQL旁边出有PHPMyAdmin工具和一些数据库的操作。下面来创建FTP账号，点击FTP账号图标，跳转到如下界面： 在这里你就可以创建你的FTP账号了，记住左边目录的public_html一定要勾选上，因为你使用ftp上传的文件都会保存在public_html文件中，所以这个一定要勾选；然后输入用户名和密码（自己设计） 创建成功之后如下下： 然后下载FTP工具测试一下，是可以连接成功的。我使用的随时Flash FXP这个ftp上传工具，因为这个官网是要收钱的，只能免费使用30天，所以楼主无奈之下只能出下策，使用下面这个别人分享的绿色破解版的： 链接: https://pan.baidu.com/s/1qYEodqO 密码: f85p 直接下载下来解压之后就可以使用了，不需要安装，直接运行.exe文件就能运行，有一点小烦人就是每次你想连接自己的云空间，都要重新输入一次主机名，密码，用户名； 创建MySQL数据库比较简单，点击MySQL图标，出现如下： 输入你的数据库名称和用户名，自己设计好密码就可以了，之后在使用htp上传文件就完事大大吉了！ 这个是楼主亲测可以使用的办法，这样不花一分钱就可以免费拥有了自己的域名和云空间，就可以在编程的的过程中把一些图片文件上传上去，直接使用服务器加载岂不快哉!如果你有什么意见或者建议，可以直接通过qq或者邮箱联系我？感谢您废了这么长的时间来看这篇博文，也希望我的一份贡献能帮您减少很多的弯路！]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>域名和网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-baidu-map在react-native中的使用]]></title>
    <url>%2F2017%2F06%2F20%2Freact-native-baidu-map%E5%9C%A8react-native%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[转载请注明地址：http://blog.csdn.net/sinat_37059404/article/details/73330041github官网地址：https://github.com/lovebing/react-native-baidu-map 下载方式：npm install react-native-baidu-map –save 插件使用过程中需要配置的内容：1，在项目的 android/settings.gradle目录 下添加： include ‘:app’include ‘:react-native-baidu-map’project(‘:react-native-baidu-map’).projectDir = new File(settingsDir, ‘../node_modules/react-native-baidu-map/android’) 2， 在android/app/build.gradle 中添加：dependencies { compile project(‘:react-native-baidu-map’) // 添加的一行 compile fileTree(dir: “libs”, include: [“*.jar”]) compile “com.android.support:appcompat-v7:23.0.1” compile “com.facebook.react:react-native:+” // From node_modules}3， 在android/app/src/main/AndroidManifest.xml 中添加：这个地方需要修改两个地方，一个是修改权限，权限问题就是你需要获取百度的网络定位能；一个是添加 meta-data，这个就是百度开发的key了，可以从百度里面直接找到具体申请方法，按照步骤做就可以了 1234567891011121314151617181920212223&lt;!-- 这个权限用于进行网络定位--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;/uses-permission&gt; &lt;!-- 这个权限用于访问GPS定位--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt;&lt;application ... &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;I03Xwhn5L3uVBrYSRfG8KzSrSZQkaM8h&quot;/&gt; // 申请到的baidu地图app key ，这个是主要添加的标签，之后再说如何获取百度的key ... &lt;/application&gt; 4, 在android/app/src/main/Java/[…]/MainApplication.java 中添加： import org.lovebing.reactnative.baidumap.BaiduMapPackage; //添加 @Override protected List getPackages() { return Arrays.asList( new MainReactPackage(), //注意这个地方的逗号 new BaiduMapPackage(getApplicationContext()) // 添加 ); }5， index.android.js 添加功能实现(导入相关功能组件)：也可以在你需要引入地图的界面修改；BaiduMapDemo组件是官网上的demo，需要复制下载在你的项目中做成一个你的组件来用，直接引入是找不到这个的； 12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry,&#125; from &apos;react-native&apos;;import BaiduMapDemo from &apos;./BaiduMapDemo&apos; //需在index.android.js同级目录下添加BaiduMapDemo.js文档export default class BaiDuMapDemo extends Component &#123; render() &#123; return ( &lt;BaiduMapDemo/&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;myrnbaidumap&apos;, () =&gt; BaiDuMapDemo); 6，然后在运行就可以了申请百度的key可以参考:http://lbsyun.baidu.com/index.php?title=androidsdk/guide/key 使用的话可以根据官网的哪个demo改一些就可以用了]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-splash-screen的心酸历程]]></title>
    <url>%2F2017%2F06%2F20%2Freact-native-splash-screen%E7%9A%84%E5%BF%83%E9%85%B8%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[楼主学习react-antive的时候，在Android项目中，电脑原因太卡了，跑项目能跑一天才能跑起来，想死的心都有了！而且跑到手机上之后老是白屏， 所以想着能不能用开源的包来打包一下，让初始化进入项目的时候，让项目的初始化白屏变成一个动画图片，于是从度娘找到了react-native-splash-screen这个伟大的包，痛苦总是有的，但结果还算开心！太坑了就是，以下分享我的痛苦历程： 一，基础配置 第一步（下载）：从react-native的根目录下下载包 1234567891011121314151617181920 npm i react-native-splash-screen --save&gt; 第二步（安装）：：安装包：一种是自动安装，一种是手动安装（楼主是自动安装的，所以就只介绍自动安装的方法了，具体手动安装的可以去官网查看）`react-native link react-native-splash-screen 或者 rnpm link react-native-splash-screen` 第三步（配置）： （1） 在 Android的目录：android/app/src/main/java/com/uto/ MainActivity.java下更新你的 MainActivity.java 文件如下：import android.os.Bundle;import com.facebook.react.ReactActivity;import com.cboy.rn.splashscreen.SplashScreen;public class MainActivity extends ReactActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123;//如果这个函数没有，就自行添加 SplashScreen.show(this); // here super.onCreate(savedInstanceState); &#125; // ...other code&#125; 第四步（运行）：前面的都是官网可以查到的，后面运行的时候各种调试，各种bug都可能出现。一般都是因为你的文件目录和内容没引对 导致项目运行失败 1， 将 react-native-splash-screen 导入你的JS 文件（你的项目的路由路由第一个加载的组件）。 import SplashScreen from ‘react-native-splash-screen’ 12 二，针对不同的终端的配置对于Android中需要配置的内容: 创建一个名为 launch_screen.xml 的布局文件来自定义你的启动屏幕。最坑的地方就在这里：如果你要添加一个名为launch_screen.xml文件，这个文件需要放在 android/app/src/main/res/layout下，如果没有layout文件，你就要新建一个layout文件并把xml文件放进去；另外，你还要在res目录下新建一个 drawable-xhdpi文件夹，里面放你想要在初始加载的时候展示的图片，图片的名称要为launch_screen.png；如果不是这样设置的就回出现各种不懂得bug，都是因为这个文件导致的，比如说could not create deotory；还有就是java.io.Exception,还有一个是aapt，说Java的sdk爆炸了，其实根源都在这里。 这是你的launch_xml文件``&lt;?xml version=”1.0” encoding=”utf-8”?&gt; ` 如果这些都设置好之后，在你的APPRegistry的类中设置，加载render之前运行这个 1234componentDidMount() &#123; // do anything while splash screen keeps, use await to wait for an async task. SplashScreen.hide();//关闭启动屏幕 &#125; iOS的配置： iOS可以通过LaunchImage或LaunchScreen.xib来自定义你的启动屏幕 转载请注明转载源地址：http://blog.csdn.net/sinat_37059404/article/details/72729694]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo基础操作]]></title>
    <url>%2F2017%2F06%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>