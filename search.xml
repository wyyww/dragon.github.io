<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树三种遍历的非递归思路（JAVASCRIPT)]]></title>
    <url>%2F2017%2F07%2F27%2Fbinary_tree_traversal%2F</url>
    <content type="text"><![CDATA[二叉树在图论中是这样定义的：二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。然而，没有足够的信息来区分左结点和右结点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。 这里，我使用javascript来写二叉树遍历的三种非递归方式，因为楼主学的是javascript，对于C，JAVA，C++这个都不是很熟，所以就只好使用javascript代替； 前序遍历第一种方法 12345678910111213141516171819202122232425var preorderTraversal = function(root) &#123; var stack = []; var res = []; var p = root; if(root == null)return []; while(stack.length!=0 || p!=null)&#123;//Side by side to join the array, and deposited in the stack, the future need to use these root nodes into the right sub-tree while(p!=null)&#123; stack.push(p); res.push(p.val); p = p.left; &#125; // When p is empty, it means that both the root and the left subtree are traversed, and the right tree goes if(stack.length!=0)&#123; p = stack.pop(); p = p.right; &#125; &#125; return res;&#125;; 第二种方法 12345678910111213141516var preorderTraversal = function(root) &#123; var result = []; var stack = []; var p = root; while(stack.length!=0 || p != null) &#123; if(p != null) &#123; stack.push(p); result.push(p.val); // Add before going to children p = p.left; &#125; else &#123; var node = stack.pop(); p = node.right; &#125; &#125; return result;&#125;; 中序遍历第一种方法 12345678910111213141516171819202122var inorderTraversal = function(root) &#123; var stack = []; var res = []; var p = root; if(root == null) return []; while( stack.length!=0 || p!=null)&#123; while(p!=null)&#123; stack.push(p); p = p.left; &#125; if(stack.length!=0)&#123; p= stack.pop(); res.push(p.val); p = p.right; &#125; &#125; return res;&#125;; 第二种方法12345678910111213141516var inorderTraversal = function(root) &#123; var result = []; var stack = []; var p = root; while(stack.length!=0 || p != null) &#123; if(p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; var node = stack.pop(); result.push(node.val); // Add after all left children p = node.right; &#125; &#125; return result;&#125;; 后序遍历第一种方法 123456789101112131415161718192021222324var postorderTraversal = function(root) &#123; var Stack = []; var result = []; if(root==null) return []; Stack.push(root); while(Stack.length!=0) &#123; var node= Stack.pop(); result.push(node.val); if(node.left) Stack.push(node.left); if(node.right) Stack.push(node.right); &#125; return result.reverse(); &#125;; 第二种方法 1234567891011121314151617var postorderTraversal = function(root) &#123; var result = []; var stack = []; var p = root; while(stack.length!=0 || p != null) &#123; if(p != null) &#123; stack.push(p); result.unshift(p.val); // Reverse the process of preorder p = p.right; // Reverse the process of preorder &#125; else &#123; var node = stack.pop(); p = node.left; // Reverse the process of preorder &#125; &#125; return result;&#125;;]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉链表的建立和三种遍历的递归方式]]></title>
    <url>%2F2017%2F07%2F25%2Fbinary_tree%2F</url>
    <content type="text"><![CDATA[二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。 一棵深度为k，且有2^k-1个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。 二叉树的建立过程是二叉链表的方式，即当前结点不光存储当前结点的数据，还存储左右孩子的指针 这里多加了一个level用来判断结点在第几层 二叉树中的中序和后序遍历都是因为结点的建立问题，不能用于建立一个二叉树12345678910include&lt;stdlib.h&gt;include&lt;stdio.h&gt;typedef char ElemType;//二叉链表的构建形式typedef struct binaryTree&#123; ElemType data; struct binaryTree *lchild,*rchild;&#125;binaryTree,*BiTree; 12345//访问一个结点并打印void visited(char c,int level)&#123; printf(&quot;%c在第%d层 \n&quot;,c, level);&#125; 1234567891011121314151617//使用前序的方式建立一个二叉树void PreorderCreateBinaryTree(BiTree *T)&#123; char c; scanf(&quot;%c&quot;,&amp;c); if( &apos;#&apos; == c) &#123; *T = NULL; &#125; else&#123; *T = (BiTree)malloc(sizeof(binaryTree)); (*T)-&gt;data = c; PreorderCreateBinaryTree(&amp;(*T)-&gt;lchild); PreorderCreateBinaryTree(&amp;(*T)-&gt;rchild); &#125;&#125; 12345678910//前序遍历二叉树void PreorderTraversal(BiTree T,int level)&#123; if( T ) &#123; visited(T-&gt;data,level); PreorderTraversal(T-&gt;lchild,level + 1); PreorderTraversal(T-&gt;rchild, level + 1); &#125;&#125; 12345678910//中序遍历二叉树void OrderTraversal(BiTree T ,int level)&#123; if( T ) &#123; PreorderTraversal(T-&gt;lchild,level + 1); visited(T-&gt;data,level); PreorderTraversal(T-&gt;rchild,level + 1); &#125;&#125; 12345678910//后序遍历二叉树void PosteriorTraversal(BiTree T,int level)&#123; if( T ) &#123; PosteriorTraversal(T-&gt;lchild,level + 1); PosteriorTraversal(T-&gt;rchild,level + 1); visited(T-&gt;data,level); &#125;&#125; 123456789101112131415161718192021222324252627282930//层序的方式实现二叉树的遍历--------------------------------------------//利用递归的方法，按层进行打印，我们把根节点当做第0层，之后层次依次增加，如果我们想打印第二层怎么办呢，利用递归的代码如下：int sequence_traversal_level(BiTree T, int level) &#123; if (!T || level &lt; 0) //当树的结点不存在，并且或者根节点不存在（深度小于0）的时候，结束 return 0; if (0 == level) &#123; //当level为0的时候，说明这一层遍历完成，需要换行 printf(&quot;%c &quot;,T-&gt;data); return 1; &#125; return sequence_traversal_level(T-&gt;lchild, level - 1) + sequence_traversal_level(T-&gt;rchild, level - 1);//左右孩子的返回值加一次为0，才能确定没有下一层，否则就需要遍历下一层；&#125;//如果我们成功的打印了给定的层次，那么就返回非0的正值，如果失败返回0。//有了这个思路，我们就可以应用一个循环，来打印这颗树的所有层的节点，但是有个问题就是我们不知道这棵二叉树的深度，//怎么来控制循环使其结束呢，仔细看一下sequence_traversal_level，如果指定的Tree是空的，那么就直接返回0，//当返回0的时候，我们就结束循环，说明没有节点可以打印了。void sequence_traversal(BiTree T) &#123; int i = 0; for (i = 0; ; i++) &#123; if (!sequence_traversal_level(T, i)) //当链表中的第i层不存在的时候退出，或者树为空的时候 遍历完成，退出循环 &#123; break; &#125; else&#123; //否则就是该层次打印完成，换行 printf(&quot;\n&quot;); &#125; &#125; printf(&quot;\n&quot;);&#125; 12345678910int main()&#123; BiTree T; int level = 1; printf(&quot;建立二叉树并访问节点&quot;); printf(&quot;请输入结点数据，建立树:\n&quot;); PreorderCreateBinaryTree(&amp;T); PosteriorTraversal(T , level); return 0;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用命令行查看使用npm全局安装的包]]></title>
    <url>%2F2017%2F07%2F07%2Fnpm%E5%8C%85%2F</url>
    <content type="text"><![CDATA[在使用node的使用，用npm安装了很多包，一个项目一个项目的接，所以对于手机全局安装的包就不是很清楚，从google上找到一个快捷命令，直接就可以列出来全局安装的包 npm list -g --depth 0 命令行截图： -g:全局的安装包list：已安装的node包–depth 0：这个参数我不是很清楚，应该是根目录的意思把]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络中OSI七层模型各层的功能]]></title>
    <url>%2F2017%2F07%2F05%2Fosi%2F</url>
    <content type="text"><![CDATA[物理层物理层的主要功能是：利用传输媒质为数据链里层提供物理连接，实现比特流的透明传输 数据链路层数据链路层的主要功能是：通过各种控制协议，将有差错的物理信道变成无差错，能可靠传输数据帧的数据链路； 网络层网络层的主要功能是：通过路由选择算法，威豹纹或分组通过子网选择最合适的路径。该层控制数据链路层与传输层之间的信息转发，建立，维持和中指网络的连接； 传输层传输层的功能是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，传输层的的作用是向高层屏蔽下层数据通信的细节，即向用户透明的传递报文； 会话层会话层的功能：向两个实体的表示层提供建立和使用连接的方法，组织和协调两个会话进程之间的通信，并对数据交换进行管理； 表示层表示层的功能：对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传递给会话层； 应用层应用层的功能：直接向用户提供服务，完成用户希望在网络上完成的各种工作；]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用hexo，github和注册域名搭建个人博客系统]]></title>
    <url>%2F2017%2F07%2F03%2Fhexo-domain%2F</url>
    <content type="text"><![CDATA[在程序员的世界里，越来越多的人重视开源和博客的构建，如果在找工作中你能在github上有一个issue或者有几个开源项目被别人采纳，或者你有一个属于自己的博客系统，博文被更多人所赞同，那么这在你的求职过程中将会有莫大的帮助；作为一名程序猿，在学习的过程中渐渐感觉到知识体系越来越丰富，那么把这些零碎的知识写成博客放在服务器端不失为一种很明智的选择，LZ自己根据hexo博客系统自己搭了一个博客，在这里跟大家分享；欢迎点评，指点，本人将万分感激； 一，hexo必要配置：window下 node必须要安装： 用来生成静态页面，可以在nodejs官网下载最新版本的，根据步骤一路安装即可 git必须安装： git的作用是用来把静态的博客提交到github 下载地址：https://www.sourcetreeapp.com/，该版本是中文的github必须安装：用来做远端的服务器，域名来用，网上很多这中文章，自己注册一个根据步骤来就好 1234567hexo在本地全局下载安装：简单的配置hexo如下所示 1，npm install hexo-cli -g:在命令行终端运行该命令就会在全局下载安装hexo的脚手架 2， hexo init：建立一个专门用来存放hexo博客文的文件夹，然后在文件夹根目录下运行hexo init或者hexo init blog这样就会创建一个博客文件夹，在这里里面可以配置你的博客，存放博客文（可以用csdn的markdown来制作博客文，这个还可以下载到本地，md文件后缀） 3，从csdn博客那里下载一个制作好的博客文章，放到blog\source\_posts目录下，_posts文件夹专门用于存放你的文章 4，运行hexo server 在命令行运行该命令可以在本地浏览器查看hexo博客文章的样式，方便简洁，直接在本地浏览器输入http://localhost:4000就可以在浏览器查看你的博客文章； 下面是我建立博客的根目录 但是到这里你才刚把hexo搭建好，还不能在服务器上访问，我这里暂时使用的是github提供的github pages，这是github提供的静态页面托管服务器，只要注册了github账号就可以使用；具体可参考github pages 二，下面说一下如何来配置github；1，在你的github账号上面新建一个Repository，这个Repository的名字必须为your_user_name.github.io;这是一个固定的写法，这样就建立了你自己的一个github仓库，你可以使用这个作为你的服务器来托管你的静态博客页面； 2，建立github和本地blog根目录的一个关联 12345配置你的_config.yml文件（根目录下），注意hexo中：后面跟内容必须加空格 deploy: type: git repository: https://github.com/your_user_name/your_user_name.github.io.git branch: master 1然后执行npm install hexo-deployer-git --save执行这个命令之后你才可以使用git把你的文章部署到github上 1最后执行一下hexo deploy就可以把你制作好的文章部署到github上去 三，将自己的域名和github解析经过上面两个步骤虽然已经建立好自己的博客，而且你可以对自己的博客进行修改，添加等，但是始终用的是别人的服务器，总有点受制于人的感觉；所以我又自己注册了一个域名，并把域名映射到github的服务器，这样直接使用我注册的域名就可以访问我的博文，拜托了github的魔杖； 首先你要有一个域名对吧，在国内比较好的域名注册网站就是阿里云，腾讯云，百度元，楼主注册了一个阿里云的账号；国外也可以注册免费域名，网站地址为http://www.freenom.com/zh/index.html?lang=zh,注册流程可以问度娘，这里不再叙述 注册过域名之后，进入阿里云的控制台 之后点击最右侧对的解析，将你的域名解析成github的 下面这个从网上查找的办法不可行，无法正常解析在这里记录类型选择CNAME，用来将域名指向一个域名，实现与被指向域名相同的访问效果；主机类型选择：*，用来指定所有的子域名都将指向同一地址。最后记录值就是你需要指定域名指向的地址，没有http,也没有www;然后保存等待域名解析完成之后就可以访问个人域名来达到访问github指定域名的效果； 可行的域名解析办法 在阿里云管理控制台中,选择【域名】》【域名列表】》【全部域名】中刚刚购买的域名,点击解析按钮这时会提醒你选择解析到阿里云主机,或者其他主机,这时需要将你在Github上创建的Github Pages的域名 xxx.github.io进行查询,得到一个IP地址。 151.101.72.133是我的github的地址（就是xiangzhihong.github.io地址，你也可以ping自己的xx.github.io，个人建议使用ping,方便快捷，不用费事从github查）. 按照这个方式解析就可以了；一般解析完成也就十分钟左右，太长了就说明你的解析不正确； Github解析在Github的xxx.github.io项目,进入【Settings】标签页,在【Custom domain】功能中,将刚刚申请的域名写进去。 如果你填写正确。就会出现上方哪个：Your site is published at …… 这样填写完成之后呢，看样子万事大吉了，解析完成之后，你使用xxx.github.io或者你的个人域名xxx.com都可以实现访问你的域名； 但是新的问题出现了，当你在客户端写了一个博客之后，在重新部署到github上，你发现使用两种方式都不能打开你的博客了~这是多么让人难受的一件事情； 那么，解决办法如下： 在你的电脑上，找到你的blog根目录 在你的source文件夹中。加入一个文件夹，CNAME， 文件夹内写的就是你需要解析的域名，不需要加http:// 也不需要加www。 之后再把你的hexo博客部署到服务器上，记得一定要部署，不然还是没有办法达到修改的目的； 请注意，注册域名之后一定要实名认证，认证需要等三到五天，记住一定要实名认证，否则你的解析结果将一直 最后就完成了实现域名到服务器的映射，你就可以使用自己的域名来实现自己的博客，感觉很神奇把。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费打造个人网站，免费域名，免费空间，ftp使用，数据库等，免费就能搭建个人网站]]></title>
    <url>%2F2017%2F07%2F02%2Fdomain-name-server%2F</url>
    <content type="text"><![CDATA[作为一名编程爱好者，有自己的一个域名空间是逼格多高的一件事啊，使用自己的云空间可以做很多事情，不管你是前端，后端，测试，软件工程师，有一个存储自己内容的独立空间，并且由你自己支配，使用；想想逼格就很高；下面介绍LZ在拼杀了两天的时间才测试出来的一套完整建立自己网站的流程，亲测有效！ 个人成果展示 通过个人域名，访问服务器图片： 通过个人域名，访问个人写的简易网页： 第一，使用freenom注册免费个人域名并解析到个人空间想要建站必须要有自己的域名吧，所以说首先需要建立一个属于自己独特的域名很重要，国内比较好的可以用腾讯云或者百度云，这里我们使用国外的一个免费提供域名的网站http://www.freenom.com/zh/index.html?lang=zh,从上面的图中可以看到我的域名就是一个以tk结尾的顶级域名，使用freenom可以注册比如.tk,.ml.ga,.cf的顶级域名，进入freenom官网如下图：（这里我已经把官网翻译为中文，LZ看不懂英文） 之后你就可以输入你想要注册的域名，查询一下你的域名是否可以注册，一般来说，普通的域名都是可以注册的； 点击你想要注册域名后缀的哪个，现在获取，一般freenom提供的是1到1年的都有，在这一年之内可以免费使用，到距离一年还有一个月的时候会邮箱提醒你域名续费，这个续费也是不要钱的；可以免费续费，就是说你可以一直用着这个域名了；获取之后，域名会被添加到你的购物车中，在购物车中你可以选择使用这个域名多久，一年之内都是免费的，记住，你可能需要注册一个freenom账号才能使用，不过你也可以使用google账号登录，这里我是用的就是google的账号，很方便，之后使用的hostinger登录也是使用的google账号，能在很多外国网站进行登录注册； 那么现在你就有了自己的一个域名了，距离人生巅峰已经不远了 在freenom主页的service中找到My Domains点进入就是管理你的域名了， 点击右边的Manage Domain来管理解析你的域名； 如果你仅仅想让域名指向一个地址，那就选择URL Forwarding,不过这里我们要指向自己的域名服务器，选择Nameservers,打开后输入如下信息： 域名服务器最少两个，最多五个，根据后面的直接粘贴复制就好，后面我会告诉大家在哪里找到。输入完成后，点击Change Nameservers保存即可。 第二，获取免费个人空间网上其实也有很多网站都能提供给你空间，甚至直接给你一个空间免费使用，但是局限性都非常大。而我们想要的个人空间，带有FTP，MYSQL吧，所以这里我们使用https://www.hostinger.com.hk/web-hosting 因为这个网站的服务器在香港，所以跑起来加载速度会比较慢，你完全可以使用上面注册的google账号注册并且登陆： 首页就有免费云空间的介绍 点击订购云空间就可以获取自己的空间了，这里我们所使用的是第一个免费的云空间，对于个人网站来说完全够用了，因为我的已经解析过主机了，所以就没有办法截图了，当你第一次订购云主机的时候会提醒你新建云主机，这里你就能把之前注册的域名填进去，这里不需要http：// ，也不需要www，一路根据网站的操作就好,订购云主机完成之后，每次点击客户中心就可以进入到你的个人空间管理页面；如下： 在这个个人主机的控制首页里面，你可以操作你的空间的内容操作在这里都可以找到，空间的信息，数据库，和ftp都可以在这个主页中去寻找操作； 解析域名 点击账号-》信息 在获取免费域名的最后一步，有一个操作是把免费域名的DNS服务器只想你的云主机，那么在这里就会出现你应该解析的DNS地址： 从个人云主机信息的NS服务器信息可以可以看到四个DNS服务器地址，将这四个拷贝到你之前freenom注册域名的nameservers下的DNS服务器哪里就好了，这样就完成了域名和云空间的解析；也就是说你可以使用域名来访问你的云空间了： 费了一早上的时间才出现这个页面，突然觉得人生还是很美好的； FTP和MySQL下面回到管理界面，向下拉可以看到FTP和MySQL的管理选项： 可以看到在MySQL旁边出有PHPMyAdmin工具和一些数据库的操作。下面来创建FTP账号，点击FTP账号图标，跳转到如下界面： 在这里你就可以创建你的FTP账号了，记住左边目录的public_html一定要勾选上，因为你使用ftp上传的文件都会保存在public_html文件中，所以这个一定要勾选；然后输入用户名和密码（自己设计） 创建成功之后如下下： 然后下载FTP工具测试一下，是可以连接成功的。我使用的随时Flash FXP这个ftp上传工具，因为这个官网是要收钱的，只能免费使用30天，所以楼主无奈之下只能出下策，使用下面这个别人分享的绿色破解版的： 链接: https://pan.baidu.com/s/1qYEodqO 密码: f85p 直接下载下来解压之后就可以使用了，不需要安装，直接运行.exe文件就能运行，有一点小烦人就是每次你想连接自己的云空间，都要重新输入一次主机名，密码，用户名； 创建MySQL数据库比较简单，点击MySQL图标，出现如下： 输入你的数据库名称和用户名，自己设计好密码就可以了，之后在使用htp上传文件就完事大大吉了！ 这个是楼主亲测可以使用的办法，这样不花一分钱就可以免费拥有了自己的域名和云空间，就可以在编程的的过程中把一些图片文件上传上去，直接使用服务器加载岂不快哉!如果你有什么意见或者建议，可以直接通过qq或者邮箱联系我？感谢您废了这么长的时间来看这篇博文，也希望我的一份贡献能帮您减少很多的弯路！]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>域名和网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-baidu-map在react-native中的使用]]></title>
    <url>%2F2017%2F06%2F20%2Freact-native-baidu-map%E5%9C%A8react-native%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[转载请注明地址：http://blog.csdn.net/sinat_37059404/article/details/73330041github官网地址：https://github.com/lovebing/react-native-baidu-map 下载方式：npm install react-native-baidu-map –save 插件使用过程中需要配置的内容：1，在项目的 android/settings.gradle目录 下添加： include ‘:app’include ‘:react-native-baidu-map’project(‘:react-native-baidu-map’).projectDir = new File(settingsDir, ‘../node_modules/react-native-baidu-map/android’) 2， 在android/app/build.gradle 中添加：dependencies { compile project(‘:react-native-baidu-map’) // 添加的一行 compile fileTree(dir: “libs”, include: [“*.jar”]) compile “com.android.support:appcompat-v7:23.0.1” compile “com.facebook.react:react-native:+” // From node_modules}3， 在android/app/src/main/AndroidManifest.xml 中添加：这个地方需要修改两个地方，一个是修改权限，权限问题就是你需要获取百度的网络定位能；一个是添加 meta-data，这个就是百度开发的key了，可以从百度里面直接找到具体申请方法，按照步骤做就可以了 1234567891011121314151617181920212223&lt;!-- 这个权限用于进行网络定位--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;/uses-permission&gt; &lt;!-- 这个权限用于访问GPS定位--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt;&lt;application ... &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;I03Xwhn5L3uVBrYSRfG8KzSrSZQkaM8h&quot;/&gt; // 申请到的baidu地图app key ，这个是主要添加的标签，之后再说如何获取百度的key ... &lt;/application&gt; 4, 在android/app/src/main/Java/[…]/MainApplication.java 中添加： import org.lovebing.reactnative.baidumap.BaiduMapPackage; //添加 @Override protected List getPackages() { return Arrays.asList( new MainReactPackage(), //注意这个地方的逗号 new BaiduMapPackage(getApplicationContext()) // 添加 ); }5， index.android.js 添加功能实现(导入相关功能组件)：也可以在你需要引入地图的界面修改；BaiduMapDemo组件是官网上的demo，需要复制下载在你的项目中做成一个你的组件来用，直接引入是找不到这个的； 12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry,&#125; from &apos;react-native&apos;;import BaiduMapDemo from &apos;./BaiduMapDemo&apos; //需在index.android.js同级目录下添加BaiduMapDemo.js文档export default class BaiDuMapDemo extends Component &#123; render() &#123; return ( &lt;BaiduMapDemo/&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;myrnbaidumap&apos;, () =&gt; BaiDuMapDemo); 6，然后在运行就可以了申请百度的key可以参考:http://lbsyun.baidu.com/index.php?title=androidsdk/guide/key 使用的话可以根据官网的哪个demo改一些就可以用了]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-splash-screen的心酸历程]]></title>
    <url>%2F2017%2F06%2F20%2Freact-native-splash-screen%E7%9A%84%E5%BF%83%E9%85%B8%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[楼主学习react-antive的时候，在Android项目中，电脑原因太卡了，跑项目能跑一天才能跑起来，想死的心都有了！而且跑到手机上之后老是白屏， 所以想着能不能用开源的包来打包一下，让初始化进入项目的时候，让项目的初始化白屏变成一个动画图片，于是从度娘找到了react-native-splash-screen这个伟大的包，痛苦总是有的，但结果还算开心！太坑了就是，以下分享我的痛苦历程： 一，基础配置 第一步（下载）：从react-native的根目录下下载包 1234567891011121314151617181920 npm i react-native-splash-screen --save&gt; 第二步（安装）：：安装包：一种是自动安装，一种是手动安装（楼主是自动安装的，所以就只介绍自动安装的方法了，具体手动安装的可以去官网查看）`react-native link react-native-splash-screen 或者 rnpm link react-native-splash-screen` 第三步（配置）： （1） 在 Android的目录：android/app/src/main/java/com/uto/ MainActivity.java下更新你的 MainActivity.java 文件如下：import android.os.Bundle;import com.facebook.react.ReactActivity;import com.cboy.rn.splashscreen.SplashScreen;public class MainActivity extends ReactActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123;//如果这个函数没有，就自行添加 SplashScreen.show(this); // here super.onCreate(savedInstanceState); &#125; // ...other code&#125; 第四步（运行）：前面的都是官网可以查到的，后面运行的时候各种调试，各种bug都可能出现。一般都是因为你的文件目录和内容没引对 导致项目运行失败 1， 将 react-native-splash-screen 导入你的JS 文件（你的项目的路由路由第一个加载的组件）。 import SplashScreen from ‘react-native-splash-screen’ 12 二，针对不同的终端的配置对于Android中需要配置的内容: 创建一个名为 launch_screen.xml 的布局文件来自定义你的启动屏幕。最坑的地方就在这里：如果你要添加一个名为launch_screen.xml文件，这个文件需要放在 android/app/src/main/res/layout下，如果没有layout文件，你就要新建一个layout文件并把xml文件放进去；另外，你还要在res目录下新建一个 drawable-xhdpi文件夹，里面放你想要在初始加载的时候展示的图片，图片的名称要为launch_screen.png；如果不是这样设置的就回出现各种不懂得bug，都是因为这个文件导致的，比如说could not create deotory；还有就是java.io.Exception,还有一个是aapt，说Java的sdk爆炸了，其实根源都在这里。 这是你的launch_xml文件``&lt;?xml version=”1.0” encoding=”utf-8”?&gt; ` 如果这些都设置好之后，在你的APPRegistry的类中设置，加载render之前运行这个 1234componentDidMount() &#123; // do anything while splash screen keeps, use await to wait for an async task. SplashScreen.hide();//关闭启动屏幕 &#125; iOS的配置： iOS可以通过LaunchImage或LaunchScreen.xib来自定义你的启动屏幕 转载请注明转载源地址：http://blog.csdn.net/sinat_37059404/article/details/72729694]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo基础操作]]></title>
    <url>%2F2017%2F06%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>